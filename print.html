<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Starkbiter Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Starkbiter Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="starkbiter-documentation"><a class="header" href="#starkbiter-documentation">Starkbiter Documentation</a></h1>
<pre><code class="language-bash">#  â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
#  â–‘â–‘     â–‘â–‘â–‘       â–‘â–‘â–‘     â–‘â–‘â–‘      â–‘â–‘â–‘â–‘  â–‘â–‘â–‘  â–‘â–‘      â–‘â–‘â–‘       â–‘â–‘       â–‘â–‘      â–‘â–‘      â–‘â–‘â–‘
#  â–’  â–’â–’â–’â–’â–’â–’â–’â–’â–’  â–’â–’â–’â–’â–’  â–’â–’â–’  â–’â–’  â–’â–’â–’  â–’â–’â–’  â–’â–’  â–’â–’â–’  â–’â–’â–’  â–’â–’â–’â–’â–’  â–’â–’â–’â–’â–’â–’  â–’â–’â–’â–’â–’  â–’â–’â–’â–’â–’â–’  â–’â–’â–’  â–’â–’
#  â–“â–“     â–“â–“â–“â–“â–“  â–“â–“â–“â–“â–“  â–“â–“â–“  â–“â–“     â–“â–“â–“â–“â–“    â–“â–“â–“â–“â–“      â–“â–“â–“â–“â–“â–“  â–“â–“â–“â–“â–“â–“  â–“â–“â–“â–“â–“    â–“â–“â–“â–“      â–“â–“â–“
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ       â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ
#  â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆ
#  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
</code></pre>
<p><strong>Starkbiter</strong> is a powerful framework for orchestrating event-based agentic simulations on top of Starknet.
The framework features a <a href="https://github.com/xJonathanLEI/starknet-rs"><code>starknet-rs</code></a> middleware built on top of <a href="https://github.com/0xSpaceShard/starknet-devnet">starknet-devnet</a> which allows you to interact with a sandboxed Starknet Sequencer instance as if it were a live Starknet node.</p>
<h2 id="why-starkbiter"><a class="header" href="#why-starkbiter">Why Starkbiter?</a></h2>
<p>Starkbiter enables you to:</p>
<ul>
<li>ğŸ”¬ <strong>Test smart contracts</strong> against adversarial environments and dynamic parameters</li>
<li>ğŸ¤– <strong>Build autonomous agents</strong> that interact with Starknet contracts in realistic scenarios</li>
<li>ğŸ“Š <strong>Model economic systems</strong> and DeFi protocols with sophisticated simulations</li>
<li>ğŸ” <strong>Detect anomalies</strong> and vulnerabilities before deployment</li>
<li>âš¡ <strong>Rapid iteration</strong> with high-performance local testing</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The Starkbiter workspace consists of five crates:</p>
<ul>
<li><strong><code>starkbiter</code></strong>: Binary crate providing a CLI for contract bindings generation</li>
<li><strong><code>starkbiter-core</code></strong>: Core library with <code>Environment</code> sandbox and middleware for Starknet interaction</li>
<li><strong><code>starkbiter-engine</code></strong>: High-level abstractions for building simulations, agents, and behaviors</li>
<li><strong><code>starkbiter-macros</code></strong>: Proc macros to simplify development</li>
<li><strong><code>starkbiter-bindings</code></strong>: Pre-generated bindings for common utility contracts</li>
</ul>
<p>All contract bytecode runs directly using Starknet Devnet (powered by Blockifier, Starkware's sequencer implementation), ensuring your contracts are tested in an environment identical to production.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="-stateful-simulation"><a class="header" href="#-stateful-simulation">ğŸ—ï¸ Stateful Simulation</a></h3>
<p>Test contracts against dynamic, stateful environments that mirror real-world Starknet conditions.</p>
<h3 id="-event-based-architecture"><a class="header" href="#-event-based-architecture">ğŸ¯ Event-Based Architecture</a></h3>
<p>Build reactive agents that respond to blockchain events, enabling complex behavioral modeling.</p>
<h3 id="-full-json-rpc-support"><a class="header" href="#-full-json-rpc-support">ğŸ”Œ Full JSON-RPC Support</a></h3>
<p>Complete Starknet node capabilities with additional methods for controlling block production and deployments.</p>
<h3 id="-high-performance"><a class="header" href="#-high-performance">ğŸš€ High Performance</a></h3>
<p>Local execution provides unmatched speed for rapid testing and iteration.</p>
<h3 id="-forking-support"><a class="header" href="#-forking-support">ğŸ§ª Forking Support</a></h3>
<p>Fork from any Starknet network state to test against real mainnet or testnet conditions.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="smart-contract-testing"><a class="header" href="#smart-contract-testing">Smart Contract Testing</a></h3>
<p>Move beyond static, stateless tests. Simulate contracts in adversarial environments with various parameters and agent behaviors.</p>
<h3 id="defi-protocol-development"><a class="header" href="#defi-protocol-development">DeFi Protocol Development</a></h3>
<p>Model complex economic systems with multiple interacting agents, market conditions, and edge cases.</p>
<h3 id="simulation-driven-development"><a class="header" href="#simulation-driven-development">Simulation-Driven Development</a></h3>
<p>Build tests that validate not just code correctness, but economic incentives and mechanism design.</p>
<h3 id="strategy-backtesting"><a class="header" href="#strategy-backtesting">Strategy Backtesting</a></h3>
<p>Test trading strategies, liquidation bots, and other autonomous agents against thousands of scenarios.</p>
<h3 id="security-auditing"><a class="header" href="#security-auditing">Security Auditing</a></h3>
<p>Perform domain-specific fuzzing and anomaly detection to uncover vulnerabilities before deployment.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready to start building with Starkbiter? Here's what you need:</p>
<ol>
<li><strong><a href="./getting_started/installation.html">Installation</a></strong> - Set up Rust and install Starkbiter</li>
<li><strong><a href="./getting_started/quick_start.html">Quick Start</a></strong> - Your first simulation in 5 minutes</li>
<li><strong><a href="./getting_started/examples.html">Examples</a></strong> - Learn from working examples</li>
</ol>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>Starkbiter's architecture is built around three core components:</p>
<h3 id="environment"><a class="header" href="#environment">Environment</a></h3>
<p>A sandboxed Starknet instance that provides:</p>
<ul>
<li>Full sequencer capabilities via Starknet Devnet</li>
<li>Complete control over block production</li>
<li>State forking from live networks</li>
<li>Contract deployment and declaration</li>
</ul>
<h3 id="middleware"><a class="header" href="#middleware">Middleware</a></h3>
<p>A familiar interface for contract interaction:</p>
<ul>
<li>Implements <code>starknet-rs</code> patterns</li>
<li>Seamless integration with existing tooling</li>
<li>Additional control methods for testing</li>
</ul>
<h3 id="engine"><a class="header" href="#engine">Engine</a></h3>
<p>High-level abstractions for simulations:</p>
<ul>
<li>Agent behaviors and event handling</li>
<li>World and universe management</li>
<li>Configuration-driven setup</li>
<li>Inter-agent messaging</li>
</ul>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<p>Here's a simple example of creating an environment and deploying a contract:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::environment::Environment;
use starknet::core::types::Felt;

// Create a new environment
let env = Environment::builder()
    .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941").unwrap())
    .build()
    .await?;

// Create an account
let account = env.create_single_owner_account(
    Felt::from_hex("0xprivate_key").unwrap(),
    Felt::from_hex("0xaccount_address").unwrap(),
).await?;

// Deploy your contracts and start simulating!
<span class="boring">}</span></code></pre></pre>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li>ğŸ“– <strong><a href="https://astraly-labs.github.io/starkbiter/">This Book</a></strong> - Complete guide and tutorials</li>
<li>ğŸ“š <strong><a href="https://docs.rs/starkbiter-core/">API Docs</a></strong> - Detailed API documentation</li>
<li>ğŸ“ <strong><a href="https://github.com/astraly-labs/starkbiter/tree/main/examples">Examples</a></strong> - Working code examples</li>
</ul>
<h3 id="crates"><a class="header" href="#crates">Crates</a></h3>
<p>All Starkbiter crates are available on crates.io:</p>
<ul>
<li><a href="https://crates.io/crates/starkbiter"><code>starkbiter</code></a> - CLI tool</li>
<li><a href="https://crates.io/crates/starkbiter-core"><code>starkbiter-core</code></a> - Core library</li>
<li><a href="https://crates.io/crates/starkbiter-engine"><code>starkbiter-engine</code></a> - Simulation engine</li>
<li><a href="https://crates.io/crates/starkbiter-macros"><code>starkbiter-macros</code></a> - Proc macros</li>
<li><a href="https://crates.io/crates/starkbiter-bindings"><code>starkbiter-bindings</code></a> - Contract bindings</li>
</ul>
<h3 id="community"><a class="header" href="#community">Community</a></h3>
<ul>
<li>ğŸ™ <strong><a href="https://github.com/astraly-labs/starkbiter">GitHub</a></strong> - Source code and issues</li>
<li>ğŸ’¬ <strong><a href="https://github.com/astraly-labs/starkbiter/discussions">Discussions</a></strong> - Ask questions and share ideas</li>
<li>ğŸ› <strong><a href="https://github.com/astraly-labs/starkbiter/issues">Issues</a></strong> - Report bugs and request features</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Starkbiter is open source and welcomes contributions! Check out our <a href="./contributing/index.html">Contributing Guide</a> to get started.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Starkbiter is licensed under the MIT License. See the <a href="https://github.com/astraly-labs/starkbiter/blob/main/LICENSE">LICENSE</a> file for details.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<p>Welcome to Starkbiter! This section will guide you through everything you need to start building simulations on Starknet.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p>In this section, you'll learn how to:</p>
<ul>
<li>Install Starkbiter and set up your development environment</li>
<li>Create your first simulation</li>
<li>Deploy and interact with Starknet contracts</li>
<li>Build agents with custom behaviors</li>
<li>Run and analyze simulations</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before starting with Starkbiter, you should have:</p>
<ul>
<li>Basic knowledge of Rust programming</li>
<li>Familiarity with Starknet and smart contracts</li>
<li>Understanding of blockchain fundamentals</li>
</ul>
<p>Don't worry if you're not an expert - we'll guide you through each step!</p>
<h2 id="setup-options"><a class="header" href="#setup-options">Setup Options</a></h2>
<h3 id="option-1-using-the-cli-recommended"><a class="header" href="#option-1-using-the-cli-recommended">Option 1: Using the CLI (Recommended)</a></h3>
<p>The Starkbiter CLI provides the easiest way to get started:</p>
<ol>
<li>Install the CLI tool</li>
<li>Generate contract bindings</li>
<li>Use pre-built templates</li>
</ol>
<p><strong>Best for:</strong> Most users, especially those new to Starkbiter</p>
<h3 id="option-2-direct-crate-usage"><a class="header" href="#option-2-direct-crate-usage">Option 2: Direct Crate Usage</a></h3>
<p>Use Starkbiter crates directly in your Rust projects:</p>
<pre><code class="language-toml">[dependencies]
starkbiter-core = "0.1"
starkbiter-bindings = "0.1"
starkbiter-engine = "0.1"
</code></pre>
<p><strong>Best for:</strong> Advanced users who want full control over their setup</p>
<h2 id="learning-path"><a class="header" href="#learning-path">Learning Path</a></h2>
<p>Follow these guides in order for the best learning experience:</p>
<ol>
<li><strong><a href="getting_started/./installation.html">Installation</a></strong> - Set up Rust and install Starkbiter</li>
<li><strong><a href="getting_started/./quick_start.html">Quick Start</a></strong> - Build your first simulation in 5 minutes</li>
<li><strong><a href="getting_started/./examples.html">Examples</a></strong> - Explore working examples and learn best practices</li>
</ol>
<h2 id="use-cases-for-starkbiter"><a class="header" href="#use-cases-for-starkbiter">Use Cases for Starkbiter</a></h2>
<h3 id="smart-contract-testing-1"><a class="header" href="#smart-contract-testing-1">Smart Contract Testing</a></h3>
<p>Test your contracts in realistic environments with multiple interacting agents, simulating mainnet conditions without deployment costs.</p>
<h3 id="defi-protocol-development-1"><a class="header" href="#defi-protocol-development-1">DeFi Protocol Development</a></h3>
<p>Model complex economic systems, test liquidation mechanisms, and validate AMM designs before going live.</p>
<h3 id="strategy-backtesting-1"><a class="header" href="#strategy-backtesting-1">Strategy Backtesting</a></h3>
<p>Develop and test trading strategies, arbitrage bots, and MEV searchers in controlled environments.</p>
<h3 id="security-auditing-1"><a class="header" href="#security-auditing-1">Security Auditing</a></h3>
<p>Perform sophisticated fuzzing, anomaly detection, and vulnerability assessment with agent-based modeling.</p>
<h2 id="support-and-resources"><a class="header" href="#support-and-resources">Support and Resources</a></h2>
<h3 id="documentation-1"><a class="header" href="#documentation-1">Documentation</a></h3>
<ul>
<li>ğŸ“– This book - comprehensive guides and tutorials</li>
<li>ğŸ“š <a href="https://docs.rs/starkbiter-core/">API docs</a> - detailed API reference</li>
<li>ğŸ“ <a href="https://github.com/astraly-labs/starkbiter/tree/main/examples">Examples</a> - working code samples</li>
</ul>
<h3 id="community-1"><a class="header" href="#community-1">Community</a></h3>
<ul>
<li>ğŸ’¬ <a href="https://github.com/astraly-labs/starkbiter/discussions">Discussions</a> - ask questions</li>
<li>ğŸ› <a href="https://github.com/astraly-labs/starkbiter/issues">Issues</a> - report bugs</li>
<li>ğŸ™ <a href="https://github.com/astraly-labs/starkbiter">GitHub</a> - source code</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Ready to start? Head to the <a href="getting_started/./installation.html">Installation</a> guide!</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide will help you install Starkbiter and set up your development environment.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before installing Starkbiter, you need to have Rust installed on your system.</p>
<h3 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h3>
<p>If you don't have Rust installed, you can install it using <a href="https://rustup.rs/">rustup</a>:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>After installation, make sure your Rust toolchain is up to date:</p>
<pre><code class="language-bash">rustup update
</code></pre>
<p>Starkbiter requires Rust 1.75 or later. You can check your Rust version with:</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<h2 id="installing-starkbiter-cli"><a class="header" href="#installing-starkbiter-cli">Installing Starkbiter CLI</a></h2>
<p>The Starkbiter CLI tool is useful for generating contract bindings and managing your projects.</p>
<h3 id="install-from-cratesio"><a class="header" href="#install-from-cratesio">Install from crates.io</a></h3>
<pre><code class="language-bash">cargo install starkbiter
</code></pre>
<h3 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h3>
<p>Check that Starkbiter was installed correctly:</p>
<pre><code class="language-bash">starkbiter --help
</code></pre>
<p>You should see the Starkbiter help menu with available commands.</p>
<h2 id="adding-starkbiter-to-your-project"><a class="header" href="#adding-starkbiter-to-your-project">Adding Starkbiter to Your Project</a></h2>
<p>To use Starkbiter in your Rust project, add the necessary crates to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
starkbiter-core = "0.1"
starkbiter-engine = "0.1"
starkbiter-bindings = "0.1"
starkbiter-macros = "0.1"

# Required dependencies
starknet = "0.11"
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<h2 id="optional-tools"><a class="header" href="#optional-tools">Optional Tools</a></h2>
<h3 id="cargo-generate"><a class="header" href="#cargo-generate">cargo-generate</a></h3>
<p>For creating new projects from templates, install <code>cargo-generate</code>:</p>
<pre><code class="language-bash">cargo install cargo-generate
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you have Starkbiter installed, continue to the <a href="getting_started/./quick_start.html">Quick Start</a> guide to create your first simulation!</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<h4 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h4>
<p>If you encounter compilation errors, make sure you have the latest stable Rust toolchain:</p>
<pre><code class="language-bash">rustup update stable
rustup default stable
</code></pre>
<h4 id="missing-system-dependencies"><a class="header" href="#missing-system-dependencies">Missing System Dependencies</a></h4>
<p>On Linux, you may need to install additional development packages:</p>
<p><strong>Ubuntu/Debian:</strong></p>
<pre><code class="language-bash">sudo apt-get update
sudo apt-get install build-essential pkg-config libssl-dev
</code></pre>
<p><strong>Fedora:</strong></p>
<pre><code class="language-bash">sudo dnf install gcc pkg-config openssl-devel
</code></pre>
<p><strong>macOS:</strong></p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<h3 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h3>
<p>If you continue to have issues:</p>
<ul>
<li>Check the <a href="https://github.com/astraly-labs/starkbiter/issues">GitHub Issues</a></li>
<li>Start a <a href="https://github.com/astraly-labs/starkbiter/discussions">Discussion</a></li>
<li>Read the <a href="getting_started/../advanced/faq.html">FAQ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>This guide will walk you through creating your first Starkbiter simulation in just a few minutes.</p>
<h2 id="your-first-simulation"><a class="header" href="#your-first-simulation">Your First Simulation</a></h2>
<p>Let's create a simple simulation that deploys and interacts with an ERC20 token contract on Starknet.</p>
<h3 id="step-1-create-a-new-project"><a class="header" href="#step-1-create-a-new-project">Step 1: Create a New Project</a></h3>
<pre><code class="language-bash">cargo new my-starkbiter-sim
cd my-starkbiter-sim
</code></pre>
<h3 id="step-2-add-dependencies"><a class="header" href="#step-2-add-dependencies">Step 2: Add Dependencies</a></h3>
<p>Edit your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = "my-starkbiter-sim"
version = "0.1.0"
edition = "2021"

[dependencies]
starkbiter-core = "0.1"
starkbiter-bindings = "0.1"
starknet = "0.11"
tokio = { version = "1.0", features = ["full"] }
anyhow = "1.0"
</code></pre>
<h3 id="step-3-create-an-environment"><a class="header" href="#step-3-create-an-environment">Step 3: Create an Environment</a></h3>
<p>Replace the contents of <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::Result;
use starkbiter_core::environment::Environment;
use starknet::core::types::Felt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create a new Starknet environment
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941").unwrap()) // Sepolia testnet
        .build()
        .await?;

    println!("âœ… Starkbiter environment created!");
    
    // Get the current block number
    let block_number = env.get_block_number().await?;
    println!("ğŸ“¦ Current block: {}", block_number);

    Ok(())
}</code></pre></pre>
<h3 id="step-4-run-your-simulation"><a class="header" href="#step-4-run-your-simulation">Step 4: Run Your Simulation</a></h3>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see:</p>
<pre><code>âœ… Starkbiter environment created!
ğŸ“¦ Current block: 0
</code></pre>
<h2 id="adding-contract-interaction"><a class="header" href="#adding-contract-interaction">Adding Contract Interaction</a></h2>
<p>Let's expand the example to deploy and interact with an ERC20 contract.</p>
<h3 id="step-1-generate-contract-bindings"><a class="header" href="#step-1-generate-contract-bindings">Step 1: Generate Contract Bindings</a></h3>
<p>First, you'll need a compiled Starknet contract. For this example, we'll use the pre-generated bindings from <code>starkbiter-bindings</code>.</p>
<p>Update your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
starkbiter-core = "0.1"
starkbiter-bindings = "0.1"
starknet = "0.11"
tokio = { version = "1.0", features = ["full"] }
anyhow = "1.0"
</code></pre>
<h3 id="step-2-deploy-and-interact"><a class="header" href="#step-2-deploy-and-interact">Step 2: Deploy and Interact</a></h3>
<p>Update <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::Result;
use starkbiter_core::environment::Environment;
use starkbiter_bindings::erc_20_mintable_oz0::ERC20;
use starknet::core::types::Felt;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create environment
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941").unwrap())
        .build()
        .await?;

    println!("âœ… Environment created");

    // Create an account
    let private_key = Felt::from_hex("0x1234").unwrap();
    let account_address = Felt::from_hex("0x1").unwrap();
    
    let account = env.create_single_owner_account(
        private_key,
        account_address
    ).await?;

    println!("âœ… Account created: {:#x}", account_address);

    // In a real scenario, you would:
    // 1. Declare the contract class
    // 2. Deploy an instance
    // 3. Interact with the deployed contract

    Ok(())
}</code></pre></pre>
<h2 id="working-with-the-example"><a class="header" href="#working-with-the-example">Working with the Example</a></h2>
<p>Starkbiter comes with a complete example. Let's run it:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/astraly-labs/starkbiter
cd starkbiter

# Run the minter example
cargo run --example minter simulate ./examples/minter/config.toml -vvvv
</code></pre>
<p>This runs a simulation with:</p>
<ul>
<li>A <strong>Token Admin</strong> agent that creates ERC20 tokens</li>
<li>A <strong>Token Requester</strong> agent that requests token minting</li>
<li>Event-based communication between agents</li>
<li>Automated token minting loop</li>
</ul>
<h2 id="understanding-the-example"><a class="header" href="#understanding-the-example">Understanding the Example</a></h2>
<p>The minter example demonstrates:</p>
<ol>
<li><strong>Environment setup</strong> - Creating a sandboxed Starknet instance</li>
<li><strong>Agent creation</strong> - Building autonomous agents with behaviors</li>
<li><strong>Event handling</strong> - Responding to blockchain events</li>
<li><strong>Inter-agent messaging</strong> - Communication between agents</li>
<li><strong>Contract interaction</strong> - Deploying and calling contracts</li>
</ol>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you've created your first simulation, explore:</p>
<ul>
<li><strong><a href="getting_started/./examples.html">Examples</a></strong> - Learn from more complex examples</li>
<li><strong><a href="getting_started/../core_concepts/architecture.html">Core Concepts</a></strong> - Understand Starkbiter's architecture</li>
<li><strong><a href="getting_started/../usage/index.html">Usage Guide</a></strong> - Deep dive into each crate</li>
<li><strong><a href="getting_started/../advanced/simulation_techniques.html">Advanced Topics</a></strong> - Advanced simulation techniques</li>
</ul>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<h3 id="logging"><a class="header" href="#logging">Logging</a></h3>
<p>Enable detailed logging with the <code>-v</code> flags:</p>
<pre><code class="language-bash">cargo run -- -v    # Info level
cargo run -- -vv   # Debug level
cargo run -- -vvv  # Trace level
</code></pre>
<h3 id="development-mode"><a class="header" href="#development-mode">Development Mode</a></h3>
<p>Use <code>cargo watch</code> for automatic recompilation:</p>
<pre><code class="language-bash">cargo install cargo-watch
cargo watch -x run
</code></pre>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<p>Write tests for your simulations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_token_minting() -&gt; Result&lt;()&gt; {
    let env = Environment::builder().build().await?;
    // Your test code here
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="environment-not-starting"><a class="header" href="#environment-not-starting">Environment Not Starting</a></h3>
<p>Make sure all dependencies are installed correctly:</p>
<pre><code class="language-bash">cargo clean
cargo build
</code></pre>
<h3 id="contract-deployment-failures"><a class="header" href="#contract-deployment-failures">Contract Deployment Failures</a></h3>
<p>Check that:</p>
<ul>
<li>Your contract is properly compiled to Sierra 1.0</li>
<li>The contract JSON is in the correct location</li>
<li>You have the necessary permissions</li>
</ul>
<h3 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h3>
<ul>
<li>Check the <a href="https://docs.rs/starkbiter-core/">API Documentation</a></li>
<li>Browse <a href="https://github.com/astraly-labs/starkbiter/tree/main/examples">Examples</a></li>
<li>Ask on <a href="https://github.com/astraly-labs/starkbiter/discussions">GitHub Discussions</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>This page provides an overview of the examples included with Starkbiter. These examples demonstrate key features and best practices for building simulations.</p>
<h2 id="running-the-examples"><a class="header" href="#running-the-examples">Running the Examples</a></h2>
<p>All examples are located in the <a href="https://github.com/astraly-labs/starkbiter/tree/main/examples">examples</a> directory of the Starkbiter repository.</p>
<p>To run an example:</p>
<pre><code class="language-bash"># Clone the repository if you haven't already
git clone https://github.com/astraly-labs/starkbiter
cd starkbiter

# Run an example
cargo run --example &lt;example_name&gt;
</code></pre>
<h2 id="available-examples"><a class="header" href="#available-examples">Available Examples</a></h2>
<h3 id="token-minter-simulation"><a class="header" href="#token-minter-simulation">Token Minter Simulation</a></h3>
<p><strong>Location:</strong> <code>examples/minter/</code></p>
<p>A comprehensive example demonstrating event-based agent communication and contract interaction.</p>
<p><strong>Run it:</strong></p>
<pre><code class="language-bash">cargo run --example minter simulate ./examples/minter/config.toml -vvvv
</code></pre>
<p><strong>What it demonstrates:</strong></p>
<ul>
<li>Creating and managing multiple agents</li>
<li>Event-based communication between agents</li>
<li>ERC20 token deployment and interaction</li>
<li>High-level messaging between agents</li>
<li>Configuration-driven simulation setup</li>
</ul>
<p><strong>How it works:</strong></p>
<p>The simulation involves two agents:</p>
<ol>
<li>
<p><strong>Token Admin (TA):</strong></p>
<ul>
<li>Creates and deploys ERC20 contracts</li>
<li>Subscribes to a high-level messenger for mint requests</li>
<li>Mints tokens upon receiving requests</li>
</ul>
</li>
<li>
<p><strong>Token Requester (TR):</strong></p>
<ul>
<li>Subscribes to <code>TokenMinted</code> events from ERC20 contracts</li>
<li>Requests more tokens when minting events are detected</li>
<li>Creates an endless loop until a threshold is reached</li>
</ul>
</li>
</ol>
<p><strong>Key Code Locations:</strong></p>
<ul>
<li><code>examples/minter/main.rs</code> - Entry point and setup</li>
<li><code>examples/minter/behaviors/token_admin.rs</code> - Admin agent logic</li>
<li><code>examples/minter/behaviors/token_requester.rs</code> - Requester agent logic</li>
<li><code>examples/minter/config.toml</code> - Configuration file</li>
</ul>
<p><strong>Learning outcomes:</strong></p>
<ul>
<li>Agent behavior patterns</li>
<li>Event subscription and handling</li>
<li>Inter-agent messaging</li>
<li>Contract lifecycle management</li>
</ul>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<p>The minter example uses a TOML configuration file. Here's what you can configure:</p>
<pre><code class="language-toml"># Environment settings
[environment]
chain_id = "0x534e5f5345504f4c4941"  # Starknet Sepolia

# Agent configurations
[agents.token_admin]
# Admin-specific settings

[agents.token_requester]
# Requester-specific settings
</code></pre>
<h2 id="advanced-example-forking"><a class="header" href="#advanced-example-forking">Advanced Example: Forking</a></h2>
<p>Starkbiter supports forking from live Starknet networks to test against real state.</p>
<p><strong>Basic forking example:</strong></p>
<pre><pre class="playground"><code class="language-rust">use starkbiter_core::environment::Environment;
use starknet::core::types::Felt;
use url::Url;
use std::str::FromStr;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Fork from Starknet mainnet at a specific block
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f4d41494e").unwrap())
        .with_fork(
            Url::from_str("https://starknet-mainnet.public.blastapi.io")?,
            1000, // Block number to fork from
            Some(Felt::from_hex("0xblock_hash").unwrap()),
        )
        .build()
        .await?;

    // Now you can interact with mainnet state locally!
    let block = env.get_block_number().await?;
    println!("Forked at block: {}", block);

    Ok(())
}</code></pre></pre>
<p><strong>What forking enables:</strong></p>
<ul>
<li>Test against real mainnet/testnet state</li>
<li>Simulate interactions with live protocols</li>
<li>Debug issues without spending real tokens</li>
<li>Analyze historical scenarios</li>
</ul>
<p><strong>Note:</strong> Forking requires an active RPC endpoint during simulation.</p>
<h2 id="building-your-own-examples"><a class="header" href="#building-your-own-examples">Building Your Own Examples</a></h2>
<h3 id="template-structure"><a class="header" href="#template-structure">Template Structure</a></h3>
<p>Here's a basic template for creating your own simulation:</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::Result;
use starkbiter_core::environment::Environment;
use starkbiter_engine::{Agent, Behavior, World};
use starknet::core::types::Felt;

// Define your behavior
struct MyBehavior;

impl Behavior for MyBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Your agent logic here
        Ok(())
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // 1. Create environment
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941")?)
        .build()
        .await?;

    // 2. Create world and agents
    let world = World::new(env);
    let agent = Agent::new("my-agent", MyBehavior);
    
    // 3. Run simulation
    world.add_agent(agent);
    world.run().await?;

    Ok(())
}</code></pre></pre>
<h3 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h3>
<ol>
<li><strong>Modular behaviors:</strong> Keep behavior logic in separate files</li>
<li><strong>Configuration-driven:</strong> Use TOML files for simulation parameters</li>
<li><strong>Logging:</strong> Add comprehensive logging with <code>tracing</code> or <code>log</code> crates</li>
<li><strong>Error handling:</strong> Use <code>anyhow</code> or <code>thiserror</code> for robust error handling</li>
<li><strong>Testing:</strong> Write unit tests for individual behaviors</li>
</ol>
<h2 id="example-projects-gallery"><a class="header" href="#example-projects-gallery">Example Projects Gallery</a></h2>
<p>Looking for more inspiration? Check out these community examples:</p>
<ul>
<li><strong>DEX Arbitrage Bot:</strong> Simulates arbitrage opportunities across multiple DEXes</li>
<li><strong>Liquidation Engine:</strong> Models liquidation mechanisms for lending protocols</li>
<li><strong>MEV Searcher:</strong> Demonstrates MEV extraction strategies</li>
<li><strong>Oracle Price Feed:</strong> Simulates price feed updates and consumer reactions</li>
</ul>
<p><em>Note: Community examples are maintained by their respective authors</em></p>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>After exploring the examples:</p>
<ol>
<li><strong>Modify an example</strong> - Change parameters and observe the results</li>
<li><strong>Combine patterns</strong> - Mix concepts from different examples</li>
<li><strong>Build your own</strong> - Create a simulation for your use case</li>
<li><strong>Share it</strong> - Contribute your example back to the community!</li>
</ol>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="example-wont-run"><a class="header" href="#example-wont-run">Example Won't Run</a></h3>
<pre><code class="language-bash"># Clean and rebuild
cargo clean
cargo build --example &lt;example_name&gt;
</code></pre>
<h3 id="missing-dependencies"><a class="header" href="#missing-dependencies">Missing Dependencies</a></h3>
<pre><code class="language-bash"># Update dependencies
cargo update
</code></pre>
<h3 id="configuration-errors"><a class="header" href="#configuration-errors">Configuration Errors</a></h3>
<p>Make sure your config file paths are correct:</p>
<pre><code class="language-bash">cargo run --example minter simulate ./examples/minter/config.toml
</code></pre>
<h2 id="getting-help-2"><a class="header" href="#getting-help-2">Getting Help</a></h2>
<ul>
<li>ğŸ“– Read the <a href="getting_started/../usage/index.html">Usage Guide</a></li>
<li>ğŸ’¬ Ask in <a href="https://github.com/astraly-labs/starkbiter/discussions">Discussions</a></li>
<li>ğŸ› Report issues on <a href="https://github.com/astraly-labs/starkbiter/issues">GitHub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h1>
<p>Starkbiter's architecture is designed to provide a seamless simulation experience while maintaining compatibility with existing Starknet tooling. This chapter explains the high-level architecture and how different components work together.</p>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         User Code                            â”‚
â”‚  (Agents, Behaviors, Simulations)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Starkbiter Engine                          â”‚
â”‚  â€¢ Agent Management                                          â”‚
â”‚  â€¢ Behavior Orchestration                                    â”‚
â”‚  â€¢ World &amp; Universe Abstractions                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Starkbiter Core                           â”‚
â”‚  â€¢ Environment (Sandbox)                                     â”‚
â”‚  â€¢ Middleware (starknet-rs compatible)                       â”‚
â”‚  â€¢ Token Management                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Starknet Devnet                             â”‚
â”‚  â€¢ Blockifier (Sequencer Implementation)                     â”‚
â”‚  â€¢ JSON-RPC Interface                                        â”‚
â”‚  â€¢ State Management                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="1-starkbiter-core"><a class="header" href="#1-starkbiter-core">1. Starkbiter Core</a></h3>
<p>The foundation of Starkbiter, providing low-level primitives for Starknet interaction.</p>
<p><strong>Key Responsibilities:</strong></p>
<ul>
<li><strong>Environment Management:</strong> Creates and manages sandboxed Starknet instances</li>
<li><strong>Middleware Layer:</strong> Provides <code>starknet-rs</code> compatible interface for contract interaction</li>
<li><strong>State Control:</strong> Manages blockchain state, block production, and time manipulation</li>
<li><strong>Account Management:</strong> Handles account creation and deployment</li>
</ul>
<p><strong>Key Types:</strong></p>
<ul>
<li><code>Environment</code> - Sandboxed Starknet instance</li>
<li><code>CheatingProvider</code> - Middleware with additional testing capabilities</li>
<li><code>Connection</code> - Manages RPC communication</li>
</ul>
<h3 id="2-starkbiter-engine"><a class="header" href="#2-starkbiter-engine">2. Starkbiter Engine</a></h3>
<p>High-level abstractions for building complex simulations.</p>
<p><strong>Key Responsibilities:</strong></p>
<ul>
<li><strong>Agent Lifecycle:</strong> Creates, manages, and coordinates agents</li>
<li><strong>Behavior Execution:</strong> Schedules and runs agent behaviors</li>
<li><strong>Event System:</strong> Handles blockchain events and inter-agent messaging</li>
<li><strong>World Management:</strong> Provides simulation environments with shared state</li>
</ul>
<p><strong>Key Types:</strong></p>
<ul>
<li><code>Agent</code> - Autonomous entity with behaviors</li>
<li><code>Behavior</code> - Trait for defining agent actions</li>
<li><code>World</code> - Simulation environment</li>
<li><code>Universe</code> - Collection of worlds</li>
<li><code>Messager</code> - Inter-agent communication</li>
</ul>
<h3 id="3-starkbiter-cli"><a class="header" href="#3-starkbiter-cli">3. Starkbiter CLI</a></h3>
<p>Command-line tools for project management.</p>
<p><strong>Key Responsibilities:</strong></p>
<ul>
<li><strong>Binding Generation:</strong> Creates Rust bindings from Cairo contracts</li>
<li><strong>Project Templates:</strong> Scaffolds new simulation projects</li>
<li><strong>Build Tools:</strong> Compiles and manages contract artifacts</li>
</ul>
<h3 id="4-starkbiter-bindings"><a class="header" href="#4-starkbiter-bindings">4. Starkbiter Bindings</a></h3>
<p>Pre-generated bindings for common contracts.</p>
<p><strong>Includes:</strong></p>
<ul>
<li>ERC20 tokens</li>
<li>Account contracts (Argent, OpenZeppelin)</li>
<li>DEX contracts (Ekubo)</li>
<li>Utility contracts</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<h3 id="contract-deployment-flow"><a class="header" href="#contract-deployment-flow">Contract Deployment Flow</a></h3>
<pre><code>User Code
    â”‚
    â””â”€&gt; Environment.declare_contract()
            â”‚
            â””â”€&gt; Devnet declares contract class
                    â”‚
                    â””â”€&gt; Returns class hash
    
User Code
    â”‚
    â””â”€&gt; Environment.deploy_contract()
            â”‚
            â””â”€&gt; Devnet deploys instance
                    â”‚
                    â””â”€&gt; Returns contract address
</code></pre>
<h3 id="transaction-execution-flow"><a class="header" href="#transaction-execution-flow">Transaction Execution Flow</a></h3>
<pre><code>Agent Behavior
    â”‚
    â””â”€&gt; Contract.call_method()
            â”‚
            â””â”€&gt; Middleware prepares transaction
                    â”‚
                    â””â”€&gt; Devnet executes transaction
                            â”‚
                            â”œâ”€&gt; Updates state
                            â”œâ”€&gt; Emits events
                            â””â”€&gt; Returns receipt
                                    â”‚
                                    â””â”€&gt; Agent processes result
</code></pre>
<h3 id="event-handling-flow"><a class="header" href="#event-handling-flow">Event Handling Flow</a></h3>
<pre><code>Contract emits event
    â”‚
    â””â”€&gt; Devnet captures event
            â”‚
            â””â”€&gt; Environment polls for events
                    â”‚
                    â””â”€&gt; Event distributed to subscribers
                            â”‚
                            â””â”€&gt; Agent behaviors triggered
</code></pre>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<h3 id="1-compatibility-first"><a class="header" href="#1-compatibility-first">1. Compatibility First</a></h3>
<p>Starkbiter maintains compatibility with <code>starknet-rs</code> to ensure:</p>
<ul>
<li>Seamless integration with existing code</li>
<li>Familiar APIs for developers</li>
<li>Easy transition between testing and production</li>
</ul>
<h3 id="2-layered-abstraction"><a class="header" href="#2-layered-abstraction">2. Layered Abstraction</a></h3>
<p>Each layer serves a specific purpose:</p>
<ul>
<li><strong>Low-level (Core):</strong> Maximum control and flexibility</li>
<li><strong>Mid-level (Engine):</strong> Balanced abstraction for common patterns</li>
<li><strong>High-level (User Code):</strong> Domain-specific logic</li>
</ul>
<h3 id="3-performance-oriented"><a class="header" href="#3-performance-oriented">3. Performance Oriented</a></h3>
<ul>
<li>Local execution eliminates network latency</li>
<li>Efficient state management</li>
<li>Optimized for rapid iteration</li>
</ul>
<h3 id="4-testing-first"><a class="header" href="#4-testing-first">4. Testing First</a></h3>
<p>Built specifically for testing scenarios:</p>
<ul>
<li>Time manipulation</li>
<li>State snapshots and rollbacks</li>
<li>Deterministic execution</li>
<li>Block production control</li>
</ul>
<h2 id="integration-points"><a class="header" href="#integration-points">Integration Points</a></h2>
<h3 id="with-starknet-rs"><a class="header" href="#with-starknet-rs">With Starknet-rs</a></h3>
<p>Starkbiter implements <code>starknet-rs</code> traits:</p>
<ul>
<li><code>Provider</code> - For read operations</li>
<li><code>Account</code> - For transaction signing and submission</li>
</ul>
<p>This allows seamless use of:</p>
<ul>
<li>Contract bindings generated with <code>cainome</code></li>
<li>Existing Starknet libraries</li>
<li>Standard tooling</li>
</ul>
<h3 id="with-starknet-devnet"><a class="header" href="#with-starknet-devnet">With Starknet Devnet</a></h3>
<p>Starkbiter wraps Starknet Devnet to provide:</p>
<ul>
<li>Full sequencer capabilities</li>
<li>JSON-RPC interface</li>
<li>State forking</li>
<li>Additional testing methods</li>
</ul>
<h3 id="with-cairo-contracts"><a class="header" href="#with-cairo-contracts">With Cairo Contracts</a></h3>
<p>Starkbiter works with standard Cairo contracts:</p>
<ul>
<li>Compiled to Sierra 1.0</li>
<li>Standard JSON format</li>
<li>ABI compatibility</li>
</ul>
<h2 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h2>
<h3 id="synchronous-simulation"><a class="header" href="#synchronous-simulation">Synchronous Simulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create environment
let env = Environment::builder().build().await?;

// Operations execute immediately
let account = env.create_account(...).await?;
let contract = deploy_contract(&amp;account, ...).await?;

// State is updated synchronously
let result = contract.transfer(...).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="event-driven-simulation"><a class="header" href="#event-driven-simulation">Event-Driven Simulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Agents react to events
let mut agent = Agent::new("trader", TradingBehavior);

agent.on_event("SwapExecuted", |event| {
    // React to DEX swaps
    handle_swap(event)
});

// Engine coordinates execution
world.add_agent(agent);
world.run().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-and-state-management"><a class="header" href="#memory-and-state-management">Memory and State Management</a></h2>
<h3 id="environment-lifecycle"><a class="header" href="#environment-lifecycle">Environment Lifecycle</a></h3>
<ol>
<li><strong>Initialization:</strong> Devnet starts with genesis state</li>
<li><strong>Execution:</strong> State updates with each transaction</li>
<li><strong>Cleanup:</strong> Resources released on drop</li>
</ol>
<h3 id="state-isolation"><a class="header" href="#state-isolation">State Isolation</a></h3>
<p>Each <code>Environment</code> instance:</p>
<ul>
<li>Has its own isolated state</li>
<li>Independent block production</li>
<li>Separate account namespaces</li>
</ul>
<h3 id="forking"><a class="header" href="#forking">Forking</a></h3>
<p>When forking from live networks:</p>
<ul>
<li>Initial state loaded lazily</li>
<li>Missing state fetched on-demand</li>
<li>Local modifications isolated</li>
</ul>
<h2 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h2>
<h3 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h3>
<p>Starkbiter uses Tokio for async execution:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let env = Environment::builder().build().await?;
    // Concurrent operations
    let (r1, r2) = tokio::join!(
        operation1(&amp;env),
        operation2(&amp;env),
    );
    Ok(())
}</code></pre></pre>
<h3 id="agent-concurrency"><a class="header" href="#agent-concurrency">Agent Concurrency</a></h3>
<p>Multiple agents can execute concurrently:</p>
<ul>
<li>Coordinated by the engine</li>
<li>Shared state through the world</li>
<li>Message passing for communication</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<p>Starkbiter defines structured errors:</p>
<ul>
<li><code>EnvironmentError</code> - Environment setup and operation failures</li>
<li><code>ContractError</code> - Contract deployment and interaction errors</li>
<li><code>AgentError</code> - Agent execution failures</li>
</ul>
<h3 id="error-propagation"><a class="header" href="#error-propagation">Error Propagation</a></h3>
<p>Errors use <code>anyhow</code> or <code>thiserror</code> for:</p>
<ul>
<li>Rich context</li>
<li>Easy error chaining</li>
<li>Flexible handling</li>
</ul>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="core_concepts/./environment.html">Environment</a> - Deep dive into the Environment API</li>
<li><a href="core_concepts/./middleware.html">Middleware</a> - Understanding the middleware layer</li>
<li><a href="core_concepts/./forking.html">Forking</a> - State forking from live networks</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="environment-1"><a class="header" href="#environment-1">Environment</a></h1>
<p>The <code>Environment</code> is the core abstraction in Starkbiter, representing a sandboxed Starknet instance. It provides complete control over blockchain state, block production, and contract interaction.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>An <code>Environment</code> wraps a Starknet Devnet instance, giving you:</p>
<ul>
<li>Full JSON-RPC capabilities</li>
<li>Additional testing methods (cheating methods)</li>
<li>State management and control</li>
<li>Account creation and management</li>
</ul>
<p>Think of it as your personal Starknet network that you have complete control over.</p>
<h2 id="creating-an-environment"><a class="header" href="#creating-an-environment">Creating an Environment</a></h2>
<h3 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use starkbiter_core::environment::Environment;
use starknet::core::types::Felt;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941")?)
        .build()
        .await?;
    
    println!("Environment ready!");
    Ok(())
}</code></pre></pre>
<h3 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h3>
<p>The <code>EnvironmentBuilder</code> provides a fluent API for configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_chain_id(chain_id)
    .with_gas_price(100_000_000_000)  // 100 gwei
    .with_block_time(10)               // 10 seconds per block
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h2>
<h3 id="chain-id"><a class="header" href="#chain-id">Chain ID</a></h3>
<p>Specify which network to simulate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Starknet Mainnet
let mainnet_id = Felt::from_hex("0x534e5f4d41494e")?;

// Starknet Sepolia Testnet
let sepolia_id = Felt::from_hex("0x534e5f5345504f4c4941")?;

let env = Environment::builder()
    .with_chain_id(sepolia_id)
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="block-time"><a class="header" href="#block-time">Block Time</a></h3>
<p>Control block production:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic block production every 5 seconds
let env = Environment::builder()
    .with_block_time(5)
    .build()
    .await?;

// Manual block production
let env = Environment::builder()
    .with_block_time(0)  // 0 = manual mode
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="gas-configuration"><a class="header" href="#gas-configuration">Gas Configuration</a></h3>
<p>Set gas prices:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_gas_price(50_000_000_000)  // 50 gwei
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<h3 id="block-production"><a class="header" href="#block-production">Block Production</a></h3>
<p>Control when blocks are produced:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual block production
env.mine_block().await?;

// Mine multiple blocks
env.mine_blocks(10).await?;

// Get current block number
let block_num = env.get_block_number().await?;
println!("Current block: {}", block_num);
<span class="boring">}</span></code></pre></pre>
<h3 id="time-manipulation"><a class="header" href="#time-manipulation">Time Manipulation</a></h3>
<p>Control blockchain time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Increase time by 1 hour
env.increase_time(3600).await?;

// Set specific timestamp
env.set_timestamp(1234567890).await?;

// Get current timestamp
let timestamp = env.get_timestamp().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="state-snapshots"><a class="header" href="#state-snapshots">State Snapshots</a></h3>
<p>Save and restore state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Take a snapshot
let snapshot_id = env.snapshot().await?;

// Make some changes
contract.do_something().await?;

// Restore to snapshot
env.restore(snapshot_id).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="account-management"><a class="header" href="#account-management">Account Management</a></h2>
<h3 id="creating-accounts"><a class="header" href="#creating-accounts">Creating Accounts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::Felt;

// Create with random keys
let account = env.create_account().await?;

// Create with specific keys
let private_key = Felt::from_hex("0x123...")? ;
let account_address = Felt::from_hex("0x456...")?;

let account = env.create_single_owner_account(
    private_key,
    account_address
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="predeployed-accounts"><a class="header" href="#predeployed-accounts">Predeployed Accounts</a></h3>
<p>Devnet comes with predeployed accounts for testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get predeployed accounts
let accounts = env.get_predeployed_accounts().await?;

for account in accounts {
    println!("Address: {:#x}", account.address);
    println!("Private Key: {:#x}", account.private_key);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="contract-management"><a class="header" href="#contract-management">Contract Management</a></h2>
<h3 id="declaring-contracts"><a class="header" href="#declaring-contracts">Declaring Contracts</a></h3>
<p>Before deploying, contracts must be declared:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;

// Read contract JSON
let contract_json = fs::read_to_string("path/to/contract.json")?;

// Declare the contract
let class_hash = env.declare_contract(
    &amp;account,
    contract_json
).await?;

println!("Contract declared: {:#x}", class_hash);
<span class="boring">}</span></code></pre></pre>
<h3 id="deploying-contracts"><a class="header" href="#deploying-contracts">Deploying Contracts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::Felt;

// Deploy with constructor args
let constructor_args = vec![
    Felt::from(1000u64),  // Initial supply
    Felt::from_hex("0x...")?,  // Owner address
];

let contract_address = env.deploy_contract(
    &amp;account,
    class_hash,
    constructor_args
).await?;

println!("Contract deployed at: {:#x}", contract_address);
<span class="boring">}</span></code></pre></pre>
<h3 id="using-bindings"><a class="header" href="#using-bindings">Using Bindings</a></h3>
<p>With <code>cainome</code>-generated bindings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::erc_20_mintable_oz0::ERC20;

// Deploy using binding
let erc20 = ERC20::deploy(
    &amp;account,
    name,
    symbol,
    decimals,
    initial_supply,
    recipient
).await?;

// Interact with contract
let balance = erc20.balance_of(address).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="querying-state"><a class="header" href="#querying-state">Querying State</a></h2>
<h3 id="block-information"><a class="header" href="#block-information">Block Information</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get latest block
let block = env.get_block_latest().await?;
println!("Block number: {}", block.block_number);
println!("Timestamp: {}", block.timestamp);

// Get specific block
let block = env.get_block_by_number(100).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-information"><a class="header" href="#transaction-information">Transaction Information</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get transaction by hash
let tx = env.get_transaction(tx_hash).await?;

// Get transaction receipt
let receipt = env.get_transaction_receipt(tx_hash).await?;

// Get transaction status
let status = env.get_transaction_status(tx_hash).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="contract-state"><a class="header" href="#contract-state">Contract State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get contract storage
let storage_value = env.get_storage_at(
    contract_address,
    storage_key
).await?;

// Get contract nonce
let nonce = env.get_nonce(contract_address).await?;

// Get contract class
let contract_class = env.get_class_at(contract_address).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h2>
<h3 id="polling-for-events"><a class="header" href="#polling-for-events">Polling for Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get events from latest block
let events = env.get_events(
    from_block,
    to_block,
    contract_address,
    keys
).await?;

for event in events {
    println!("Event: {:?}", event);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-filtering"><a class="header" href="#event-filtering">Event Filtering</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::EventFilter;

let filter = EventFilter {
    from_block: Some(0),
    to_block: Some(100),
    address: Some(contract_address),
    keys: Some(vec![event_key]),
};

let events = env.get_events_filtered(filter).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="forking-1"><a class="header" href="#forking-1">Forking</a></h2>
<p>Fork from live networks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use url::Url;
use std::str::FromStr;

let env = Environment::builder()
    .with_chain_id(mainnet_id)
    .with_fork(
        Url::from_str("https://starknet-mainnet.public.blastapi.io")?,
        12345,  // Block number
        Some(Felt::from_hex("0xblock_hash")?),
    )
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>See <a href="core_concepts/./forking.html">Forking</a> for more details.</p>
<h2 id="cheating-methods"><a class="header" href="#cheating-methods">Cheating Methods</a></h2>
<p>Starkbiter provides additional testing methods:</p>
<h3 id="impersonation"><a class="header" href="#impersonation">Impersonation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impersonate an address
env.start_prank(target_address, impersonator_address).await?;

// Make calls as the impersonator
contract.privileged_function().await?;

// Stop impersonating
env.stop_prank(target_address).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="balance-manipulation"><a class="header" href="#balance-manipulation">Balance Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set ETH balance
env.set_balance(address, amount).await?;

// Get balance
let balance = env.get_balance(address).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-manipulation"><a class="header" href="#storage-manipulation">Storage Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Write directly to storage
env.store(
    contract_address,
    storage_key,
    value
).await?;

// Load from storage
let value = env.load(contract_address, storage_key).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="cleanup-and-shutdown"><a class="header" href="#cleanup-and-shutdown">Cleanup and Shutdown</a></h2>
<p>Environments are automatically cleaned up when dropped:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let env = Environment::builder().build().await?;
    // Use env
} // env is dropped, resources cleaned up
<span class="boring">}</span></code></pre></pre>
<p>Explicit shutdown:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env.shutdown().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-use-builder-pattern"><a class="header" href="#1-use-builder-pattern">1. Use Builder Pattern</a></h3>
<p>Always use the builder for consistent configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_chain_id(chain_id)
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-error-handling"><a class="header" href="#2-error-handling">2. Error Handling</a></h3>
<p>Always handle environment errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match env.get_block_number().await {
    Ok(block) =&gt; println!("Block: {}", block),
    Err(e) =&gt; eprintln!("Error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-resource-management"><a class="header" href="#3-resource-management">3. Resource Management</a></h3>
<p>Create environments in appropriate scopes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_contract() -&gt; Result&lt;()&gt; {
    let env = Environment::builder().build().await?;
    // Test code
    Ok(())
} // Environment cleaned up automatically
<span class="boring">}</span></code></pre></pre>
<h3 id="4-snapshots-for-testing"><a class="header" href="#4-snapshots-for-testing">4. Snapshots for Testing</a></h3>
<p>Use snapshots to isolate test cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let snapshot = env.snapshot().await?;

// Test case 1
run_test_1(&amp;env).await?;
env.restore(snapshot).await?;

// Test case 2  
run_test_2(&amp;env).await?;
env.restore(snapshot).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="deploy-and-initialize"><a class="header" href="#deploy-and-initialize">Deploy and Initialize</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn deploy_and_initialize(env: &amp;Environment) -&gt; Result&lt;ContractAddress&gt; {
    let account = env.create_account().await?;
    
    // Declare
    let class_hash = env.declare_contract(&amp;account, contract_json).await?;
    
    // Deploy
    let address = env.deploy_contract(&amp;account, class_hash, vec![]).await?;
    
    // Initialize
    let contract = MyContract::new(address, &amp;account);
    contract.initialize().await?;
    
    Ok(address)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="time-based-testing"><a class="header" href="#time-based-testing">Time-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn test_time_lock(env: &amp;Environment) -&gt; Result&lt;()&gt; {
    let contract = deploy_timelock(&amp;env).await?;
    
    // Try before time lock expires (should fail)
    assert!(contract.withdraw().await.is_err());
    
    // Fast forward
    env.increase_time(86400).await?;  // +24 hours
    env.mine_block().await?;
    
    // Now should succeed
    contract.withdraw().await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="core_concepts/./middleware.html">Middleware</a> - Understanding the middleware layer</li>
<li><a href="core_concepts/./forking.html">Forking</a> - State forking from live networks</li>
<li><a href="core_concepts/../usage/starkbiter_core/index.html">Usage Guide</a> - Detailed API reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="middleware-1"><a class="header" href="#middleware-1">Middleware</a></h1>
<p>The middleware layer in Starkbiter provides a familiar interface for interacting with Starknet contracts, compatible with the <code>starknet-rs</code> ecosystem. This chapter explains how middleware works and how to use it effectively.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>Starkbiter's middleware implements the standard <code>Provider</code> trait from <code>starknet-rs</code>, extended with additional "cheating" methods for testing. This means:</p>
<ul>
<li><strong>Familiar API</strong>: If you know <code>starknet-rs</code>, you know Starkbiter</li>
<li><strong>Seamless Integration</strong>: Works with <code>cainome</code> bindings and other tooling</li>
<li><strong>Extended Capabilities</strong>: Additional methods for testing scenarios</li>
</ul>
<h2 id="the-cheatingprovider"><a class="header" href="#the-cheatingprovider">The CheatingProvider</a></h2>
<p>The <code>CheatingProvider</code> is the main middleware implementation in Starkbiter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::middleware::CheatingProvider;

// Access through environment
let provider = env.provider();

// Use standard Provider methods
let block_number = provider.block_number().await?;
let block = provider.get_block_with_tx_hashes(block_number).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="standard-provider-methods"><a class="header" href="#standard-provider-methods">Standard Provider Methods</a></h2>
<h3 id="block-queries"><a class="header" href="#block-queries">Block Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::providers::Provider;

// Get latest block number
let block_num = provider.block_number().await?;

// Get block by number
let block = provider.get_block_with_tx_hashes(block_num).await?;

// Get block by hash
let block = provider.get_block_with_tx_hashes_by_hash(block_hash).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-queries"><a class="header" href="#transaction-queries">Transaction Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get transaction by hash
let tx = provider.get_transaction_by_hash(tx_hash).await?;

// Get transaction receipt
let receipt = provider.get_transaction_receipt(tx_hash).await?;

// Get transaction status
let status = provider.get_transaction_status(tx_hash).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="state-queries"><a class="header" href="#state-queries">State Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get storage at address
let value = provider.get_storage_at(
    contract_address,
    key,
    block_id
).await?;

// Get nonce
let nonce = provider.get_nonce(
    block_id,
    contract_address
).await?;

// Get class hash at contract
let class_hash = provider.get_class_hash_at(
    block_id,
    contract_address
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="contract-class-queries"><a class="header" href="#contract-class-queries">Contract Class Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get class
let class = provider.get_class(
    block_id,
    class_hash
).await?;

// Get class at contract address
let class = provider.get_class_at(
    block_id,
    contract_address
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="event-queries"><a class="header" href="#event-queries">Event Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::{EventFilter, EventsPage};

let filter = EventFilter {
    from_block: Some(BlockId::Number(0)),
    to_block: Some(BlockId::Number(100)),
    address: Some(contract_address),
    keys: None,
};

let events: EventsPage = provider.get_events(
    filter,
    None,  // continuation_token
    100,   // chunk_size
).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="cheating-methods-1"><a class="header" href="#cheating-methods-1">Cheating Methods</a></h2>
<p>Beyond standard Provider methods, <code>CheatingProvider</code> offers testing-specific capabilities.</p>
<h3 id="time-manipulation-1"><a class="header" href="#time-manipulation-1">Time Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current timestamp
let timestamp = provider.get_timestamp().await?;

// Set specific timestamp
provider.set_timestamp(new_timestamp).await?;

// Increase time
provider.increase_time(seconds).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="block-manipulation"><a class="header" href="#block-manipulation">Block Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mine a single block
provider.mine_block().await?;

// Mine multiple blocks
provider.mine_blocks(count).await?;

// Set block interval
provider.set_block_interval(seconds).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="account-impersonation"><a class="header" href="#account-impersonation">Account Impersonation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start impersonating an address
provider.start_prank(target_contract, impersonator).await?;

// Make calls as the impersonator
// All calls to target_contract will appear to come from impersonator

// Stop impersonating
provider.stop_prank(target_contract).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="balance-manipulation-1"><a class="header" href="#balance-manipulation-1">Balance Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set ETH balance
provider.set_balance(address, amount).await?;

// Deal tokens (if supported)
provider.deal(token_address, recipient, amount).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-manipulation-1"><a class="header" href="#storage-manipulation-1">Storage Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Write to storage
provider.store(
    contract_address,
    storage_key,
    value
).await?;

// Read from storage
let value = provider.load(
    contract_address,
    storage_key
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create snapshot
let snapshot_id = provider.snapshot().await?;

// Make changes...
contract.modify_state().await?;

// Restore to snapshot
provider.revert(snapshot_id).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="using-with-accounts"><a class="header" href="#using-with-accounts">Using with Accounts</a></h2>
<p>The middleware integrates seamlessly with Starknet accounts.</p>
<h3 id="account-creation"><a class="header" href="#account-creation">Account Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::accounts::{Account, SingleOwnerAccount};
use starknet::signers::LocalWallet;

// Create wallet
let signer = LocalWallet::from(private_key);

// Create account with the provider
let account = SingleOwnerAccount::new(
    provider.clone(),
    signer,
    account_address,
    chain_id,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="signing-transactions"><a class="header" href="#signing-transactions">Signing Transactions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::accounts::Call;

// Prepare call
let call = Call {
    to: contract_address,
    selector: get_selector_from_name("transfer")?,
    calldata: vec![recipient, amount_low, amount_high],
};

// Execute through account
let result = account.execute(vec![call]).send().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="using-with-contract-bindings"><a class="header" href="#using-with-contract-bindings">Using with Contract Bindings</a></h2>
<p>The middleware works seamlessly with <code>cainome</code>-generated bindings.</p>
<h3 id="reading-from-contracts"><a class="header" href="#reading-from-contracts">Reading from Contracts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::erc_20_mintable_oz0::ERC20;

// Create contract instance
let token = ERC20::new(token_address, &amp;account);

// Read state (calls Provider methods)
let balance = token.balance_of(address).await?;
let total_supply = token.total_supply().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="writing-to-contracts"><a class="header" href="#writing-to-contracts">Writing to Contracts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prepare transaction
let tx = token.transfer(recipient, amount);

// Execute (uses Account methods)
let result = tx.send().await?;

// Wait for confirmation
let receipt = result.wait_for_acceptance().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-management"><a class="header" href="#connection-management">Connection Management</a></h2>
<p>The middleware manages the underlying connection to Devnet.</p>
<h3 id="connection-configuration"><a class="header" href="#connection-configuration">Connection Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::middleware::Connection;

// Default configuration (automatic)
let connection = Connection::new()?;

// Custom port
let connection = Connection::with_port(5050)?;

// Custom URL
let connection = Connection::with_url("http://localhost:5050")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if Devnet is responsive
if provider.is_alive().await? {
    println!("Devnet is running");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>The middleware uses standard Starknet error types.</p>
<h3 id="common-errors"><a class="header" href="#common-errors">Common Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::providers::ProviderError;

match provider.get_block_with_tx_hashes(1000000).await {
    Ok(block) =&gt; {
        // Process block
    }
    Err(ProviderError::StarknetError(e)) =&gt; {
        // Starknet-specific error
        eprintln!("Starknet error: {:?}", e);
    }
    Err(e) =&gt; {
        // Other errors
        eprintln!("Provider error: {:?}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use Result types
async fn get_balance(
    provider: &amp;CheatingProvider,
    address: Felt,
) -&gt; Result&lt;Felt&gt; {
    let balance = provider.get_balance(address).await?;
    Ok(balance)
}

// Handle specific error cases
async fn safe_get_block(
    provider: &amp;CheatingProvider,
    block_num: u64,
) -&gt; Option&lt;Block&gt; {
    match provider.get_block_with_tx_hashes(block_num).await {
        Ok(block) =&gt; Some(block),
        Err(e) =&gt; {
            log::warn!("Failed to get block {}: {}", block_num, e);
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="concurrent-requests"><a class="header" href="#concurrent-requests">Concurrent Requests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::try_join;

// Execute multiple queries in parallel
let (balance, nonce, block) = try_join!(
    provider.get_balance(address),
    provider.get_nonce(BlockId::Pending, address),
    provider.block_number(),
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="retry-logic"><a class="header" href="#retry-logic">Retry Logic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

async fn get_receipt_with_retry(
    provider: &amp;CheatingProvider,
    tx_hash: Felt,
    max_retries: u32,
) -&gt; Result&lt;TransactionReceipt&gt; {
    for attempt in 0..max_retries {
        match provider.get_transaction_receipt(tx_hash).await {
            Ok(receipt) =&gt; return Ok(receipt),
            Err(e) if attempt &lt; max_retries - 1 =&gt; {
                sleep(Duration::from_millis(100)).await;
                continue;
            }
            Err(e) =&gt; return Err(e.into()),
        }
    }
    unreachable!()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="polling-for-events-1"><a class="header" href="#polling-for-events-1">Polling for Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn watch_for_event(
    provider: &amp;CheatingProvider,
    contract: Felt,
    event_key: Felt,
) -&gt; Result&lt;Event&gt; {
    let mut last_block = provider.block_number().await?;
    
    loop {
        let current_block = provider.block_number().await?;
        
        if current_block &gt; last_block {
            let events = provider.get_events(
                EventFilter {
                    from_block: Some(BlockId::Number(last_block + 1)),
                    to_block: Some(BlockId::Number(current_block)),
                    address: Some(contract),
                    keys: Some(vec![vec![event_key]]),
                },
                None,
                100,
            ).await?;
            
            if let Some(event) = events.events.first() {
                return Ok(event.clone());
            }
            
            last_block = current_block;
        }
        
        sleep(Duration::from_millis(100)).await;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-middleware"><a class="header" href="#testing-with-middleware">Testing with Middleware</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use starkbiter_core::environment::Environment;

    #[tokio::test]
    async fn test_provider_queries() {
        let env = Environment::builder().build().await.unwrap();
        let provider = env.provider();
        
        let block_num = provider.block_number().await.unwrap();
        assert_eq!(block_num, 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_contract_interaction() {
    let env = Environment::builder().build().await?;
    let provider = env.provider();
    let account = env.create_account().await?;
    
    // Deploy contract
    let contract = deploy_test_contract(&amp;account).await?;
    
    // Interact through provider
    let call = Call {
        to: contract.address,
        selector: get_selector_from_name("set_value")?,
        calldata: vec![Felt::from(42u64)],
    };
    
    account.execute(vec![call]).send().await?;
    
    // Verify
    let value = contract.get_value().await?;
    assert_eq!(value, Felt::from(42u64));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="core_concepts/./environment.html">Environment</a> - Deep dive into Environment</li>
<li><a href="core_concepts/./forking.html">Forking</a> - State forking from live networks</li>
<li><a href="core_concepts/../usage/starkbiter_core/middleware.html">Usage Guide</a> - Detailed middleware API</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="forking-2"><a class="header" href="#forking-2">Forking</a></h1>
<p>Forking allows you to create a local simulation based on the state of a live Starknet network. This is incredibly powerful for testing against real mainnet/testnet conditions without spending real tokens.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>When you fork a network, Starkbiter:</p>
<ol>
<li>Connects to a live Starknet RPC endpoint</li>
<li>Fetches state lazily (only when needed)</li>
<li>Stores state locally for fast access</li>
<li>Allows you to make local modifications without affecting the real network</li>
</ol>
<h2 id="basic-forking"><a class="header" href="#basic-forking">Basic Forking</a></h2>
<h3 id="fork-from-mainnet"><a class="header" href="#fork-from-mainnet">Fork from Mainnet</a></h3>
<pre><pre class="playground"><code class="language-rust">use starkbiter_core::environment::Environment;
use starknet::core::types::Felt;
use url::Url;
use std::str::FromStr;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f4d41494e")?)  // Mainnet
        .with_fork(
            Url::from_str("https://starknet-mainnet.public.blastapi.io")?,
            100000,  // Block number to fork from
            None,    // Optional: block hash for verification
        )
        .build()
        .await?;
    
    // Now you have mainnet state locally!
    let block = env.get_block_number().await?;
    println!("Forked at block: {}", block);
    
    Ok(())
}</code></pre></pre>
<h3 id="fork-from-sepolia"><a class="header" href="#fork-from-sepolia">Fork from Sepolia</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941")?)
    .with_fork(
        Url::from_str("https://starknet-sepolia.public.blastapi.io")?,
        50000,
        None,
    )
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="block-selection"><a class="header" href="#block-selection">Block Selection</a></h3>
<p>You can fork from any block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork from latest block (use a very high number)
.with_fork(rpc_url, u64::MAX, None)

// Fork from specific block
.with_fork(rpc_url, 123456, None)

// Fork with block hash verification
.with_fork(
    rpc_url,
    123456,
    Some(Felt::from_hex("0xblock_hash")?),
)
<span class="boring">}</span></code></pre></pre>
<h3 id="rpc-endpoints"><a class="header" href="#rpc-endpoints">RPC Endpoints</a></h3>
<p>Popular Starknet RPC providers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Public endpoints
const MAINNET: &amp;str = "https://starknet-mainnet.public.blastapi.io";
const SEPOLIA: &amp;str = "https://starknet-sepolia.public.blastapi.io";

// Alchemy
const ALCHEMY: &amp;str = "https://starknet-mainnet.g.alchemy.com/v2/YOUR_API_KEY";

// Infura
const INFURA: &amp;str = "https://starknet-mainnet.infura.io/v3/YOUR_PROJECT_ID";
<span class="boring">}</span></code></pre></pre>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="testing-against-real-protocols"><a class="header" href="#testing-against-real-protocols">Testing Against Real Protocols</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::erc_20_mintable_oz0::ERC20;

// Fork mainnet
let env = Environment::builder()
    .with_fork(mainnet_url, block_num, None)
    .build()
    .await?;

// Interact with real USDC contract
let usdc_address = Felt::from_hex("0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8")?;
let account = env.create_account().await?;
let usdc = ERC20::new(usdc_address, &amp;account);

// Read real state
let total_supply = usdc.total_supply().await?;
println!("USDC total supply: {}", total_supply);
<span class="boring">}</span></code></pre></pre>
<h3 id="debugging-transactions"><a class="header" href="#debugging-transactions">Debugging Transactions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork at the block before an issue occurred
let env = Environment::builder()
    .with_fork(mainnet_url, problem_block - 1, None)
    .build()
    .await?;

// Reproduce the issue locally
let tx_result = reproduce_issue(&amp;env).await?;

// Debug with full control
env.increase_time(1).await?;
let next_result = try_fix(&amp;env).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-backtesting-2"><a class="header" href="#strategy-backtesting-2">Strategy Backtesting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork from historical block
let env = Environment::builder()
    .with_fork(mainnet_url, historical_block, None)
    .build()
    .await?;

// Run your strategy against real historical state
let profit = run_strategy(&amp;env).await?;
println!("Strategy would have made: {}", profit);
<span class="boring">}</span></code></pre></pre>
<h3 id="protocol-integration-testing"><a class="header" href="#protocol-integration-testing">Protocol Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test your protocol against real DEX
let env = Environment::builder()
    .with_fork(mainnet_url, latest_block, None)
    .build()
    .await?;

// Deploy your protocol
let my_contract = deploy_my_protocol(&amp;env).await?;

// Test integration with real Jediswap/10k swap/Ekubo
let result = test_swap_integration(&amp;env, my_contract).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="lazy-state-loading"><a class="header" href="#lazy-state-loading">Lazy State Loading</a></h2>
<p>Starkbiter loads state lazily for efficiency:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork is created
let env = Environment::builder()
    .with_fork(url, block, None)
    .build()
    .await?;

// State is fetched only when accessed
let balance = env.get_balance(address).await?;  // Fetches balance
let storage = env.get_storage_at(contract, key).await?;  // Fetches storage

// Subsequent accesses use cached state
let balance2 = env.get_balance(address).await?;  // Uses cache
<span class="boring">}</span></code></pre></pre>
<h2 id="local-modifications"><a class="header" href="#local-modifications">Local Modifications</a></h2>
<p>Changes you make are local and don't affect the real network:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork mainnet
let env = Environment::builder()
    .with_fork(mainnet_url, block, None)
    .build()
    .await?;

let account = env.create_account().await?;

// Modify state locally
env.set_balance(account.address(), Felt::from(1_000_000u64)).await?;

// Deploy contracts
let my_contract = deploy_contract(&amp;account).await?;

// Make transactions
my_contract.do_something().await?;

// All changes are local - mainnet is unaffected!
<span class="boring">}</span></code></pre></pre>
<h2 id="impersonation-in-forks"><a class="header" href="#impersonation-in-forks">Impersonation in Forks</a></h2>
<p>Interact with contracts as if you were any address:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork mainnet
let env = Environment::builder()
    .with_fork(mainnet_url, block, None)
    .build()
    .await?;

// Impersonate a whale address
let whale = Felt::from_hex("0xwhale_address")?;
env.start_prank(contract_address, whale).await?;

// Make calls as the whale
let contract = Token::new(token_address, &amp;env);
contract.transfer(my_address, large_amount).await?;

env.stop_prank(contract_address).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="snapshot-and-restore-with-forks"><a class="header" href="#snapshot-and-restore-with-forks">Snapshot and Restore with Forks</a></h2>
<p>Combine forking with snapshots for powerful testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork mainnet
let env = Environment::builder()
    .with_fork(mainnet_url, block, None)
    .build()
    .await?;

// Take snapshot of forked state
let snapshot = env.snapshot().await?;

// Test scenario 1
test_scenario_1(&amp;env).await?;

// Restore forked state
env.restore(snapshot).await?;

// Test scenario 2 with same starting state
test_scenario_2(&amp;env).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="network-latency"><a class="header" href="#network-latency">Network Latency</a></h3>
<p>State fetching requires network calls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// First access: slow (network fetch)
let balance = env.get_balance(address).await?;

// Subsequent accesses: fast (cached)
let balance2 = env.get_balance(address).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-queries"><a class="header" href="#batch-queries">Batch Queries</a></h3>
<p>Optimize by batching related operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of sequential queries
let balance1 = env.get_balance(addr1).await?;
let balance2 = env.get_balance(addr2).await?;

// Use concurrent queries
use tokio::try_join;
let (balance1, balance2) = try_join!(
    env.get_balance(addr1),
    env.get_balance(addr2),
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="persistent-caching"><a class="header" href="#persistent-caching">Persistent Caching</a></h3>
<p>Consider caching fork state for repeated runs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Future enhancement (not yet implemented)
let env = Environment::builder()
    .with_fork(url, block, None)
    .with_cache_dir("./fork_cache")
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="active-connection-required"><a class="header" href="#active-connection-required">Active Connection Required</a></h3>
<p>Forking requires the RPC endpoint to remain available:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// âŒ This will fail if RPC goes down
let env = Environment::builder()
    .with_fork(unreliable_url, block, None)
    .build()
    .await?;

// First access works
let state1 = env.get_storage_at(addr, key).await?;

// If RPC goes down, subsequent fetches fail
let state2 = env.get_storage_at(other_addr, key).await?;  // Error!
<span class="boring">}</span></code></pre></pre>
<h3 id="state-consistency"><a class="header" href="#state-consistency">State Consistency</a></h3>
<p>Forked state is point-in-time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fork at block 100000
let env = Environment::builder()
    .with_fork(url, 100000, None)
    .build()
    .await?;

// State is frozen at block 100000
// Real network has moved on
// Your fork doesn't see newer transactions
<span class="boring">}</span></code></pre></pre>
<h3 id="block-hash-verification"><a class="header" href="#block-hash-verification">Block Hash Verification</a></h3>
<p>If provided, block hash must match:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This will fail if block hash doesn't match block number
let env = Environment::builder()
    .with_fork(
        url,
        123456,
        Some(wrong_block_hash),  // âŒ Error!
    )
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="1-use-recent-blocks"><a class="header" href="#1-use-recent-blocks">1. Use Recent Blocks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Recent block, less likely to be pruned
.with_fork(url, recent_block, None)

// Risky: Very old block might be pruned by RPC
.with_fork(url, very_old_block, None)
<span class="boring">}</span></code></pre></pre>
<h3 id="2-verify-block-hash-for-critical-tests"><a class="header" href="#2-verify-block-hash-for-critical-tests">2. Verify Block Hash for Critical Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For production testing, verify block hash
.with_fork(
    url,
    critical_block,
    Some(verified_block_hash),
)
<span class="boring">}</span></code></pre></pre>
<h3 id="3-handle-network-errors"><a class="header" href="#3-handle-network-errors">3. Handle Network Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = match Environment::builder()
    .with_fork(url, block, None)
    .build()
    .await
{
    Ok(env) =&gt; env,
    Err(e) =&gt; {
        eprintln!("Failed to fork: {}", e);
        // Fallback to non-forked environment
        Environment::builder().build().await?
    }
};
<span class="boring">}</span></code></pre></pre>
<h3 id="4-use-local-snapshots"><a class="header" href="#4-use-local-snapshots">4. Use Local Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// After forking, take snapshot for fast resets
let snapshot = env.snapshot().await?;

for test in tests {
    env.restore(snapshot).await?;
    test.run(&amp;env).await?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="fork-fails-to-connect"><a class="header" href="#fork-fails-to-connect">Fork Fails to Connect</a></h3>
<pre><code>Error: Failed to connect to RPC endpoint
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Check RPC URL is correct</li>
<li>Verify network connectivity</li>
<li>Try a different RPC provider</li>
<li>Check if the endpoint requires API key</li>
</ul>
<h3 id="block-not-found"><a class="header" href="#block-not-found">Block Not Found</a></h3>
<pre><code>Error: Block not found
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Verify block number exists</li>
<li>Check if block is too old (pruned)</li>
<li>Try a more recent block</li>
<li>Use an archive node for historical blocks</li>
</ul>
<h3 id="state-loading-timeout"><a class="header" href="#state-loading-timeout">State Loading Timeout</a></h3>
<pre><code>Error: Timeout fetching state
</code></pre>
<p><strong>Solutions:</strong></p>
<ul>
<li>Increase timeout duration</li>
<li>Use a faster RPC provider</li>
<li>Pre-warm cache by accessing state upfront</li>
</ul>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="core_concepts/./environment.html">Environment</a> - Deep dive into Environment API</li>
<li><a href="core_concepts/./middleware.html">Middleware</a> - Understanding the middleware layer</li>
<li><a href="core_concepts/../advanced/simulation_techniques.html">Advanced Topics</a> - Advanced simulation techniques</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="usage-guide-overview"><a class="header" href="#usage-guide-overview">Usage Guide Overview</a></h1>
<p>This section provides detailed documentation for each component of the Starkbiter framework. Whether you're building simple contract tests or complex multi-agent simulations, you'll find the information you need here.</p>
<h2 id="crates-overview"><a class="header" href="#crates-overview">Crates Overview</a></h2>
<p>Starkbiter is organized into several crates, each serving a specific purpose:</p>
<h3 id="starkbiter-core"><a class="header" href="#starkbiter-core"><a href="usage/./starkbiter_core/index.html">Starkbiter Core</a></a></h3>
<p>The foundation layer providing direct interaction with Starknet.</p>
<p><strong>Key Components:</strong></p>
<ul>
<li><code>Environment</code> - Sandboxed Starknet instance</li>
<li><code>CheatingProvider</code> - Extended middleware with testing capabilities</li>
<li>State management and control</li>
<li>Account and contract deployment</li>
</ul>
<p><strong>Best for:</strong> Low-level control, custom testing scenarios, framework integration</p>
<h3 id="starkbiter-engine"><a class="header" href="#starkbiter-engine"><a href="usage/./starkbiter_engine/index.html">Starkbiter Engine</a></a></h3>
<p>High-level abstractions for building agent-based simulations.</p>
<p><strong>Key Components:</strong></p>
<ul>
<li><code>Agent</code> - Autonomous entities with behaviors</li>
<li><code>Behavior</code> - Trait for defining agent actions</li>
<li><code>World</code> - Simulation environment</li>
<li><code>Universe</code> - Multi-world orchestration</li>
<li>Inter-agent messaging</li>
</ul>
<p><strong>Best for:</strong> Complex simulations, agent-based modeling, DeFi protocol testing</p>
<h3 id="starkbiter-cli"><a class="header" href="#starkbiter-cli"><a href="usage/./starkbiter_cli.html">Starkbiter CLI</a></a></h3>
<p>Command-line tools for project management.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>Contract binding generation</li>
<li>Project initialization</li>
<li>Build management</li>
</ul>
<p><strong>Best for:</strong> Project setup, contract integration</p>
<h3 id="starkbiter-macros"><a class="header" href="#starkbiter-macros"><a href="usage/./starkbiter_macros.html">Starkbiter Macros</a></a></h3>
<p>Procedural macros to reduce boilerplate.</p>
<p><strong>Provides:</strong></p>
<ul>
<li>Behavior derivation</li>
<li>Agent configuration</li>
<li>Simplified async patterns</li>
</ul>
<p><strong>Best for:</strong> Cleaner code, rapid development</p>
<h3 id="starkbiter-bindings"><a class="header" href="#starkbiter-bindings"><a href="usage/./starkbiter_bindings.html">Starkbiter Bindings</a></a></h3>
<p>Pre-generated contract bindings for common contracts.</p>
<p><strong>Includes:</strong></p>
<ul>
<li>ERC20 tokens</li>
<li>Account contracts</li>
<li>DEX protocols (Ekubo)</li>
<li>Test utilities</li>
</ul>
<p><strong>Best for:</strong> Quick testing, common contract interactions</p>
<h2 id="choosing-the-right-level"><a class="header" href="#choosing-the-right-level">Choosing the Right Level</a></h2>
<h3 id="use-core-when"><a class="header" href="#use-core-when">Use Core When:</a></h3>
<ul>
<li>You need maximum control over the simulation</li>
<li>Building custom testing frameworks</li>
<li>Integrating with other tools</li>
<li>Implementing novel testing patterns</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::environment::Environment;

let env = Environment::builder().build().await?;
let account = env.create_account().await?;
// Direct, low-level control
<span class="boring">}</span></code></pre></pre>
<h3 id="use-engine-when"><a class="header" href="#use-engine-when">Use Engine When:</a></h3>
<ul>
<li>Building multi-agent simulations</li>
<li>Modeling economic systems</li>
<li>Testing protocol interactions</li>
<li>Simulating user behaviors</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_engine::{Agent, World};

let world = World::new(env);
world.add_agent(Agent::new("trader", TradingBehavior));
world.run().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="use-cli-when"><a class="header" href="#use-cli-when">Use CLI When:</a></h3>
<ul>
<li>Starting new projects</li>
<li>Generating contract bindings</li>
<li>Managing build artifacts</li>
</ul>
<pre><code class="language-bash">starkbiter bind
starkbiter init my-project
</code></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="pattern-1-simple-contract-testing"><a class="header" href="#pattern-1-simple-contract-testing">Pattern 1: Simple Contract Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::environment::Environment;

#[tokio::test]
async fn test_my_contract() {
    let env = Environment::builder().build().await?;
    let account = env.create_account().await?;
    
    // Deploy and test
    let contract = deploy_contract(&amp;account).await?;
    assert_eq!(contract.get_value().await?, expected_value);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-2-multi-agent-simulation"><a class="header" href="#pattern-2-multi-agent-simulation">Pattern 2: Multi-Agent Simulation</a></h3>
<pre><pre class="playground"><code class="language-rust">use starkbiter_engine::{Agent, World, Behavior};

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let env = Environment::builder().build().await?;
    let world = World::new(env);
    
    // Add multiple agents
    world.add_agent(Agent::new("liquidator", LiquidatorBehavior));
    world.add_agent(Agent::new("borrower", BorrowerBehavior));
    world.add_agent(Agent::new("lender", LenderBehavior));
    
    // Run simulation
    world.run().await?;
    Ok(())
}</code></pre></pre>
<h3 id="pattern-3-fork-testing"><a class="header" href="#pattern-3-fork-testing">Pattern 3: Fork Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_fork(mainnet_url, block_num, None)
    .build()
    .await?;

// Test against real mainnet state
let usdc = ERC20::new(usdc_address, &amp;account);
let balance = usdc.balance_of(whale_address).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="navigation"><a class="header" href="#navigation">Navigation</a></h2>
<p>Each crate section includes:</p>
<ul>
<li><strong>Overview</strong> - What it does and when to use it</li>
<li><strong>API Reference</strong> - Detailed documentation of types and methods</li>
<li><strong>Examples</strong> - Working code samples</li>
<li><strong>Best Practices</strong> - Tips and patterns</li>
</ul>
<p>Start with the crate that matches your use case:</p>
<ul>
<li><a href="usage/./starkbiter_core/index.html">Starkbiter Core</a> - Low-level control</li>
<li><a href="usage/./starkbiter_engine/index.html">Starkbiter Engine</a> - Agent simulations</li>
<li><a href="usage/./starkbiter_cli.html">Starkbiter CLI</a> - Project tooling</li>
</ul>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li><a href="usage/../core_concepts/architecture.html">Core Concepts</a> - Architecture and design</li>
<li><a href="usage/../advanced/simulation_techniques.html">Advanced Topics</a> - Advanced techniques</li>
<li><a href="usage/../getting_started/examples.html">Examples</a> - Working examples</li>
<li><a href="https://docs.rs/starkbiter-core/">API Docs</a> - Full API reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="starkbiter-core-1"><a class="header" href="#starkbiter-core-1">Starkbiter Core</a></h1>
<p><code>starkbiter-core</code> is the foundation of the Starkbiter framework. It provides low-level primitives for interacting with Starknet in a sandboxed environment with complete control over blockchain state.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The core crate gives you:</p>
<ul>
<li><strong>Environment</strong> - A sandboxed Starknet Devnet instance</li>
<li><strong>Middleware</strong> - <code>starknet-rs</code> compatible provider with testing extensions</li>
<li><strong>State Control</strong> - Block production, time manipulation, snapshots</li>
<li><strong>Account Management</strong> - Account creation and deployment</li>
<li><strong>Contract Management</strong> - Declaration and deployment</li>
</ul>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
starkbiter-core = "0.1"
starknet = "0.11"
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust">use starkbiter_core::environment::Environment;
use starknet::core::types::Felt;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Create environment
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941")?)
        .build()
        .await?;
    
    // Create account
    let account = env.create_account().await?;
    
    // Deploy and interact with contracts
    // ...
    
    Ok(())
}</code></pre></pre>
<h2 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h2>
<h3 id="environment-2"><a class="header" href="#environment-2">Environment</a></h3>
<p>The <code>Environment</code> struct is the main entry point. It encapsulates:</p>
<ul>
<li>Starknet Devnet instance</li>
<li>Block production control</li>
<li>State management</li>
<li>Account and contract operations</li>
</ul>
<p><a href="usage/starkbiter_core/./environment.html">Learn more about Environment â†’</a></p>
<h3 id="middleware-2"><a class="header" href="#middleware-2">Middleware</a></h3>
<p>The <code>CheatingProvider</code> implements the <code>Provider</code> trait from <code>starknet-rs</code> with additional testing methods:</p>
<ul>
<li>Standard RPC calls</li>
<li>Time manipulation</li>
<li>Balance manipulation</li>
<li>Storage access</li>
<li>Impersonation</li>
</ul>
<p><a href="usage/starkbiter_core/./middleware.html">Learn more about Middleware â†’</a></p>
<h2 id="key-features-1"><a class="header" href="#key-features-1">Key Features</a></h2>
<h3 id="-full-control"><a class="header" href="#-full-control">ğŸ”§ Full Control</a></h3>
<p>Complete control over the blockchain state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Control block production
env.mine_block().await?;
env.mine_blocks(10).await?;

// Manipulate time
env.increase_time(3600).await?;  // +1 hour
env.set_timestamp(timestamp).await?;

// Take snapshots
let snapshot = env.snapshot().await?;
// ... make changes ...
env.restore(snapshot).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="-high-performance-1"><a class="header" href="#-high-performance-1">ğŸš€ High Performance</a></h3>
<p>Local execution with no network latency:</p>
<ul>
<li>Instant transaction confirmation</li>
<li>Rapid state queries</li>
<li>Fast iteration cycles</li>
</ul>
<h3 id="-compatible"><a class="header" href="#-compatible">ğŸ”Œ Compatible</a></h3>
<p>Works seamlessly with the Starknet ecosystem:</p>
<ul>
<li><code>starknet-rs</code> types and traits</li>
<li><code>cainome</code> contract bindings</li>
<li>Standard tooling and libraries</li>
</ul>
<h3 id="-testing-first"><a class="header" href="#-testing-first">ğŸ§ª Testing First</a></h3>
<p>Built specifically for testing scenarios:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impersonate addresses
env.start_prank(contract, impersonator).await?;

// Set balances
env.set_balance(address, amount).await?;

// Manipulate storage
env.store(contract, key, value).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="architecture-2"><a class="header" href="#architecture-2">Architecture</a></h2>
<pre><code>Your Code
    â†“
Environment
    â†“
CheatingProvider (Middleware)
    â†“
Starknet Devnet
    â†“
Blockifier (Sequencer)
</code></pre>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_token_transfer() {
    let env = Environment::builder().build().await?;
    let account = env.create_account().await?;
    
    let token = deploy_token(&amp;account).await?;
    token.transfer(recipient, amount).await?;
    
    let balance = token.balance_of(recipient).await?;
    assert_eq!(balance, amount);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_defi_protocol() {
    let env = Environment::builder().build().await?;
    
    // Deploy multiple contracts
    let token = deploy_token(&amp;env).await?;
    let pool = deploy_pool(&amp;env).await?;
    let router = deploy_router(&amp;env).await?;
    
    // Test interactions
    test_swap(&amp;env, &amp;router, &amp;pool).await?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fork-testing"><a class="header" href="#fork-testing">Fork Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_fork(mainnet_url, block_num, None)
    .build()
    .await?;

// Test against real mainnet state
let usdc = ERC20::new(usdc_mainnet_address, &amp;account);
let balance = usdc.balance_of(whale).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="time-based-testing-1"><a class="header" href="#time-based-testing-1">Time-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test time-locked features
let contract = deploy_timelock(&amp;env).await?;

// Try before lock expires
assert!(contract.withdraw().await.is_err());

// Fast forward
env.increase_time(lock_duration).await?;
env.mine_block().await?;

// Now succeeds
contract.withdraw().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h2>
<h3 id="environment-api"><a class="header" href="#environment-api">Environment API</a></h3>
<p>The <code>Environment</code> provides these main capabilities:</p>
<p><strong>Setup &amp; Configuration:</strong></p>
<ul>
<li><code>Environment::builder()</code> - Create environment builder</li>
<li><code>.with_chain_id()</code> - Set chain ID</li>
<li><code>.with_block_time()</code> - Configure block production</li>
<li><code>.with_fork()</code> - Fork from live network</li>
<li><code>.build()</code> - Build environment</li>
</ul>
<p><strong>Block Control:</strong></p>
<ul>
<li><code>.mine_block()</code> - Produce one block</li>
<li><code>.mine_blocks(n)</code> - Produce n blocks</li>
<li><code>.get_block_number()</code> - Get current block</li>
<li><code>.get_block()</code> - Get block details</li>
</ul>
<p><strong>Time Control:</strong></p>
<ul>
<li><code>.get_timestamp()</code> - Get current time</li>
<li><code>.set_timestamp()</code> - Set specific time</li>
<li><code>.increase_time()</code> - Advance time</li>
</ul>
<p><strong>State Management:</strong></p>
<ul>
<li><code>.snapshot()</code> - Save state</li>
<li><code>.restore()</code> - Restore state</li>
</ul>
<p><strong>Account Management:</strong></p>
<ul>
<li><code>.create_account()</code> - Create new account</li>
<li><code>.create_single_owner_account()</code> - Create with specific keys</li>
<li><code>.get_predeployed_accounts()</code> - Get test accounts</li>
</ul>
<p><strong>Contract Management:</strong></p>
<ul>
<li><code>.declare_contract()</code> - Declare contract class</li>
<li><code>.deploy_contract()</code> - Deploy contract instance</li>
</ul>
<p><a href="usage/starkbiter_core/./environment.html">Full Environment API â†’</a></p>
<h3 id="middleware-api"><a class="header" href="#middleware-api">Middleware API</a></h3>
<p>The <code>CheatingProvider</code> extends standard <code>Provider</code>:</p>
<p><strong>Standard Methods:</strong></p>
<ul>
<li><code>.block_number()</code> - Get latest block</li>
<li><code>.get_block_with_tx_hashes()</code> - Get block data</li>
<li><code>.get_transaction()</code> - Get transaction</li>
<li><code>.get_storage_at()</code> - Read storage</li>
<li><code>.get_events()</code> - Query events</li>
</ul>
<p><strong>Testing Methods:</strong></p>
<ul>
<li><code>.start_prank()</code> - Start impersonation</li>
<li><code>.stop_prank()</code> - Stop impersonation</li>
<li><code>.set_balance()</code> - Set ETH balance</li>
<li><code>.store()</code> - Write to storage</li>
<li><code>.load()</code> - Read from storage</li>
<li><code>.snapshot()</code> - Save state</li>
<li><code>.revert()</code> - Restore state</li>
</ul>
<p><a href="usage/starkbiter_core/./middleware.html">Full Middleware API â†’</a></p>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>The core crate uses standard Rust error handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;

async fn deploy_contract(env: &amp;Environment) -&gt; Result&lt;ContractAddress&gt; {
    let account = env.create_account().await?;
    let class_hash = env.declare_contract(&amp;account, contract_json).await?;
    let address = env.deploy_contract(&amp;account, class_hash, vec![]).await?;
    Ok(address)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="complete-testing-example"><a class="header" href="#complete-testing-example">Complete Testing Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::environment::Environment;
use starkbiter_bindings::erc_20_mintable_oz0::ERC20;
use starknet::core::types::Felt;
use anyhow::Result;

#[tokio::test]
async fn test_erc20_operations() -&gt; Result&lt;()&gt; {
    // Setup
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941")?)
        .build()
        .await?;
    
    let owner = env.create_account().await?;
    let recipient = env.create_account().await?;
    
    // Deploy token
    let initial_supply = Felt::from(1_000_000u64);
    let token = ERC20::deploy(
        &amp;owner,
        "Test Token",
        "TEST",
        18,
        initial_supply,
        owner.address(),
    ).await?;
    
    // Test balance
    let balance = token.balance_of(owner.address()).await?;
    assert_eq!(balance, initial_supply);
    
    // Test transfer
    let transfer_amount = Felt::from(1000u64);
    token.transfer(recipient.address(), transfer_amount).await?;
    
    let recipient_balance = token.balance_of(recipient.address()).await?;
    assert_eq!(recipient_balance, transfer_amount);
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="1-use-builder-pattern-1"><a class="header" href="#1-use-builder-pattern-1">1. Use Builder Pattern</a></h3>
<p>Always configure environments with the builder:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_chain_id(chain_id)
    .with_block_time(10)
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-handle-errors-properly"><a class="header" href="#2-handle-errors-properly">2. Handle Errors Properly</a></h3>
<p>Use <code>Result</code> and <code>?</code> operator:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn setup_test() -&gt; Result&lt;(Environment, Account)&gt; {
    let env = Environment::builder().build().await?;
    let account = env.create_account().await?;
    Ok((env, account))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-clean-up-resources"><a class="header" href="#3-clean-up-resources">3. Clean Up Resources</a></h3>
<p>Leverage Rust's ownership for automatic cleanup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn my_test() -&gt; Result&lt;()&gt; {
    let env = Environment::builder().build().await?;
    // Test code
    Ok(())
} // Environment automatically cleaned up
<span class="boring">}</span></code></pre></pre>
<h3 id="4-use-snapshots-for-isolation"><a class="header" href="#4-use-snapshots-for-isolation">4. Use Snapshots for Isolation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let snapshot = env.snapshot().await?;

for test_case in test_cases {
    env.restore(snapshot).await?;
    run_test_case(&amp;env, test_case).await?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<h3 id="parallel-testing"><a class="header" href="#parallel-testing">Parallel Testing</a></h3>
<p>Run independent tests in parallel:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test(flavor = "multi_thread")]
async fn parallel_test() {
    // Each test gets its own environment
    // Tests run concurrently
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<p>Group related operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::try_join;

let (balance, nonce, storage) = try_join!(
    env.get_balance(address),
    env.get_nonce(address),
    env.get_storage_at(contract, key),
)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_core/./environment.html">Environment API</a> - Detailed environment documentation</li>
<li><a href="usage/starkbiter_core/./middleware.html">Middleware API</a> - Detailed middleware documentation</li>
<li><a href="usage/starkbiter_core/../../getting_started/examples.html">Examples</a> - Working code examples</li>
<li><a href="usage/starkbiter_core/../../advanced/simulation_techniques.html">Advanced Topics</a> - Advanced techniques</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="environment-3"><a class="header" href="#environment-3">Environment</a></h1>
<p>The <code>Environment</code> is the core abstraction in Starkbiter, representing a sandboxed Starknet instance. It provides complete control over blockchain state, block production, and contract interaction.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>An <code>Environment</code> wraps a Starknet Devnet instance, giving you:</p>
<ul>
<li>Full JSON-RPC capabilities</li>
<li>Additional testing methods (cheating methods)</li>
<li>State management and control</li>
<li>Account creation and management</li>
</ul>
<p>Think of it as your personal Starknet network that you have complete control over.</p>
<h2 id="creating-an-environment-1"><a class="header" href="#creating-an-environment-1">Creating an Environment</a></h2>
<h3 id="basic-setup-1"><a class="header" href="#basic-setup-1">Basic Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use starkbiter_core::environment::Environment;
use starknet::core::types::Felt;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex("0x534e5f5345504f4c4941")?)
        .build()
        .await?;
    
    println!("Environment ready!");
    Ok(())
}</code></pre></pre>
<h3 id="builder-pattern-1"><a class="header" href="#builder-pattern-1">Builder Pattern</a></h3>
<p>The <code>EnvironmentBuilder</code> provides a fluent API for configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_chain_id(chain_id)
    .with_gas_price(100_000_000_000)  // 100 gwei
    .with_block_time(10)               // 10 seconds per block
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options-2"><a class="header" href="#configuration-options-2">Configuration Options</a></h2>
<h3 id="chain-id-1"><a class="header" href="#chain-id-1">Chain ID</a></h3>
<p>Specify which network to simulate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Starknet Mainnet
let mainnet_id = Felt::from_hex("0x534e5f4d41494e")?;

// Starknet Sepolia Testnet
let sepolia_id = Felt::from_hex("0x534e5f5345504f4c4941")?;

let env = Environment::builder()
    .with_chain_id(sepolia_id)
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="block-time-1"><a class="header" href="#block-time-1">Block Time</a></h3>
<p>Control block production:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic block production every 5 seconds
let env = Environment::builder()
    .with_block_time(5)
    .build()
    .await?;

// Manual block production
let env = Environment::builder()
    .with_block_time(0)  // 0 = manual mode
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="gas-configuration-1"><a class="header" href="#gas-configuration-1">Gas Configuration</a></h3>
<p>Set gas prices:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_gas_price(50_000_000_000)  // 50 gwei
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="state-management-1"><a class="header" href="#state-management-1">State Management</a></h2>
<h3 id="block-production-1"><a class="header" href="#block-production-1">Block Production</a></h3>
<p>Control when blocks are produced:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual block production
env.mine_block().await?;

// Mine multiple blocks
env.mine_blocks(10).await?;

// Get current block number
let block_num = env.get_block_number().await?;
println!("Current block: {}", block_num);
<span class="boring">}</span></code></pre></pre>
<h3 id="time-manipulation-2"><a class="header" href="#time-manipulation-2">Time Manipulation</a></h3>
<p>Control blockchain time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Increase time by 1 hour
env.increase_time(3600).await?;

// Set specific timestamp
env.set_timestamp(1234567890).await?;

// Get current timestamp
let timestamp = env.get_timestamp().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="state-snapshots-1"><a class="header" href="#state-snapshots-1">State Snapshots</a></h3>
<p>Save and restore state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Take a snapshot
let snapshot_id = env.snapshot().await?;

// Make some changes
contract.do_something().await?;

// Restore to snapshot
env.restore(snapshot_id).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="account-management-1"><a class="header" href="#account-management-1">Account Management</a></h2>
<h3 id="creating-accounts-1"><a class="header" href="#creating-accounts-1">Creating Accounts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::Felt;

// Create with random keys
let account = env.create_account().await?;

// Create with specific keys
let private_key = Felt::from_hex("0x123...")? ;
let account_address = Felt::from_hex("0x456...")?;

let account = env.create_single_owner_account(
    private_key,
    account_address
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="predeployed-accounts-1"><a class="header" href="#predeployed-accounts-1">Predeployed Accounts</a></h3>
<p>Devnet comes with predeployed accounts for testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get predeployed accounts
let accounts = env.get_predeployed_accounts().await?;

for account in accounts {
    println!("Address: {:#x}", account.address);
    println!("Private Key: {:#x}", account.private_key);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="contract-management-1"><a class="header" href="#contract-management-1">Contract Management</a></h2>
<h3 id="declaring-contracts-1"><a class="header" href="#declaring-contracts-1">Declaring Contracts</a></h3>
<p>Before deploying, contracts must be declared:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;

// Read contract JSON
let contract_json = fs::read_to_string("path/to/contract.json")?;

// Declare the contract
let class_hash = env.declare_contract(
    &amp;account,
    contract_json
).await?;

println!("Contract declared: {:#x}", class_hash);
<span class="boring">}</span></code></pre></pre>
<h3 id="deploying-contracts-1"><a class="header" href="#deploying-contracts-1">Deploying Contracts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::Felt;

// Deploy with constructor args
let constructor_args = vec![
    Felt::from(1000u64),  // Initial supply
    Felt::from_hex("0x...")?,  // Owner address
];

let contract_address = env.deploy_contract(
    &amp;account,
    class_hash,
    constructor_args
).await?;

println!("Contract deployed at: {:#x}", contract_address);
<span class="boring">}</span></code></pre></pre>
<h3 id="using-bindings-1"><a class="header" href="#using-bindings-1">Using Bindings</a></h3>
<p>With <code>cainome</code>-generated bindings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::erc_20_mintable_oz0::ERC20;

// Deploy using binding
let erc20 = ERC20::deploy(
    &amp;account,
    name,
    symbol,
    decimals,
    initial_supply,
    recipient
).await?;

// Interact with contract
let balance = erc20.balance_of(address).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="querying-state-1"><a class="header" href="#querying-state-1">Querying State</a></h2>
<h3 id="block-information-1"><a class="header" href="#block-information-1">Block Information</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get latest block
let block = env.get_block_latest().await?;
println!("Block number: {}", block.block_number);
println!("Timestamp: {}", block.timestamp);

// Get specific block
let block = env.get_block_by_number(100).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-information-1"><a class="header" href="#transaction-information-1">Transaction Information</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get transaction by hash
let tx = env.get_transaction(tx_hash).await?;

// Get transaction receipt
let receipt = env.get_transaction_receipt(tx_hash).await?;

// Get transaction status
let status = env.get_transaction_status(tx_hash).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="contract-state-1"><a class="header" href="#contract-state-1">Contract State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get contract storage
let storage_value = env.get_storage_at(
    contract_address,
    storage_key
).await?;

// Get contract nonce
let nonce = env.get_nonce(contract_address).await?;

// Get contract class
let contract_class = env.get_class_at(contract_address).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="event-handling-1"><a class="header" href="#event-handling-1">Event Handling</a></h2>
<h3 id="polling-for-events-2"><a class="header" href="#polling-for-events-2">Polling for Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get events from latest block
let events = env.get_events(
    from_block,
    to_block,
    contract_address,
    keys
).await?;

for event in events {
    println!("Event: {:?}", event);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-filtering-1"><a class="header" href="#event-filtering-1">Event Filtering</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::EventFilter;

let filter = EventFilter {
    from_block: Some(0),
    to_block: Some(100),
    address: Some(contract_address),
    keys: Some(vec![event_key]),
};

let events = env.get_events_filtered(filter).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="forking-3"><a class="header" href="#forking-3">Forking</a></h2>
<p>Fork from live networks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use url::Url;
use std::str::FromStr;

let env = Environment::builder()
    .with_chain_id(mainnet_id)
    .with_fork(
        Url::from_str("https://starknet-mainnet.public.blastapi.io")?,
        12345,  // Block number
        Some(Felt::from_hex("0xblock_hash")?),
    )
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>See <a href="usage/starkbiter_core/./forking.html">Forking</a> for more details.</p>
<h2 id="cheating-methods-2"><a class="header" href="#cheating-methods-2">Cheating Methods</a></h2>
<p>Starkbiter provides additional testing methods:</p>
<h3 id="impersonation-1"><a class="header" href="#impersonation-1">Impersonation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Impersonate an address
env.start_prank(target_address, impersonator_address).await?;

// Make calls as the impersonator
contract.privileged_function().await?;

// Stop impersonating
env.stop_prank(target_address).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="balance-manipulation-2"><a class="header" href="#balance-manipulation-2">Balance Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set ETH balance
env.set_balance(address, amount).await?;

// Get balance
let balance = env.get_balance(address).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-manipulation-2"><a class="header" href="#storage-manipulation-2">Storage Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Write directly to storage
env.store(
    contract_address,
    storage_key,
    value
).await?;

// Load from storage
let value = env.load(contract_address, storage_key).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="cleanup-and-shutdown-1"><a class="header" href="#cleanup-and-shutdown-1">Cleanup and Shutdown</a></h2>
<p>Environments are automatically cleaned up when dropped:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let env = Environment::builder().build().await?;
    // Use env
} // env is dropped, resources cleaned up
<span class="boring">}</span></code></pre></pre>
<p>Explicit shutdown:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>env.shutdown().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-use-builder-pattern-2"><a class="header" href="#1-use-builder-pattern-2">1. Use Builder Pattern</a></h3>
<p>Always use the builder for consistent configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_chain_id(chain_id)
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-error-handling-1"><a class="header" href="#2-error-handling-1">2. Error Handling</a></h3>
<p>Always handle environment errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match env.get_block_number().await {
    Ok(block) =&gt; println!("Block: {}", block),
    Err(e) =&gt; eprintln!("Error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-resource-management-1"><a class="header" href="#3-resource-management-1">3. Resource Management</a></h3>
<p>Create environments in appropriate scopes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_contract() -&gt; Result&lt;()&gt; {
    let env = Environment::builder().build().await?;
    // Test code
    Ok(())
} // Environment cleaned up automatically
<span class="boring">}</span></code></pre></pre>
<h3 id="4-snapshots-for-testing-1"><a class="header" href="#4-snapshots-for-testing-1">4. Snapshots for Testing</a></h3>
<p>Use snapshots to isolate test cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let snapshot = env.snapshot().await?;

// Test case 1
run_test_1(&amp;env).await?;
env.restore(snapshot).await?;

// Test case 2  
run_test_2(&amp;env).await?;
env.restore(snapshot).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="deploy-and-initialize-1"><a class="header" href="#deploy-and-initialize-1">Deploy and Initialize</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn deploy_and_initialize(env: &amp;Environment) -&gt; Result&lt;ContractAddress&gt; {
    let account = env.create_account().await?;
    
    // Declare
    let class_hash = env.declare_contract(&amp;account, contract_json).await?;
    
    // Deploy
    let address = env.deploy_contract(&amp;account, class_hash, vec![]).await?;
    
    // Initialize
    let contract = MyContract::new(address, &amp;account);
    contract.initialize().await?;
    
    Ok(address)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="time-based-testing-2"><a class="header" href="#time-based-testing-2">Time-Based Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn test_time_lock(env: &amp;Environment) -&gt; Result&lt;()&gt; {
    let contract = deploy_timelock(&amp;env).await?;
    
    // Try before time lock expires (should fail)
    assert!(contract.withdraw().await.is_err());
    
    // Fast forward
    env.increase_time(86400).await?;  // +24 hours
    env.mine_block().await?;
    
    // Now should succeed
    contract.withdraw().await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_core/./middleware.html">Middleware</a> - Understanding the middleware layer</li>
<li><a href="usage/starkbiter_core/./forking.html">Forking</a> - State forking from live networks</li>
<li><a href="usage/starkbiter_core/../usage/starkbiter_core/index.html">Usage Guide</a> - Detailed API reference</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="middleware-3"><a class="header" href="#middleware-3">Middleware</a></h1>
<p>The middleware layer in Starkbiter provides a familiar interface for interacting with Starknet contracts, compatible with the <code>starknet-rs</code> ecosystem. This chapter explains how middleware works and how to use it effectively.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>Starkbiter's middleware implements the standard <code>Provider</code> trait from <code>starknet-rs</code>, extended with additional "cheating" methods for testing. This means:</p>
<ul>
<li><strong>Familiar API</strong>: If you know <code>starknet-rs</code>, you know Starkbiter</li>
<li><strong>Seamless Integration</strong>: Works with <code>cainome</code> bindings and other tooling</li>
<li><strong>Extended Capabilities</strong>: Additional methods for testing scenarios</li>
</ul>
<h2 id="the-cheatingprovider-1"><a class="header" href="#the-cheatingprovider-1">The CheatingProvider</a></h2>
<p>The <code>CheatingProvider</code> is the main middleware implementation in Starkbiter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::middleware::CheatingProvider;

// Access through environment
let provider = env.provider();

// Use standard Provider methods
let block_number = provider.block_number().await?;
let block = provider.get_block_with_tx_hashes(block_number).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="standard-provider-methods-1"><a class="header" href="#standard-provider-methods-1">Standard Provider Methods</a></h2>
<h3 id="block-queries-1"><a class="header" href="#block-queries-1">Block Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::providers::Provider;

// Get latest block number
let block_num = provider.block_number().await?;

// Get block by number
let block = provider.get_block_with_tx_hashes(block_num).await?;

// Get block by hash
let block = provider.get_block_with_tx_hashes_by_hash(block_hash).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-queries-1"><a class="header" href="#transaction-queries-1">Transaction Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get transaction by hash
let tx = provider.get_transaction_by_hash(tx_hash).await?;

// Get transaction receipt
let receipt = provider.get_transaction_receipt(tx_hash).await?;

// Get transaction status
let status = provider.get_transaction_status(tx_hash).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="state-queries-1"><a class="header" href="#state-queries-1">State Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get storage at address
let value = provider.get_storage_at(
    contract_address,
    key,
    block_id
).await?;

// Get nonce
let nonce = provider.get_nonce(
    block_id,
    contract_address
).await?;

// Get class hash at contract
let class_hash = provider.get_class_hash_at(
    block_id,
    contract_address
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="contract-class-queries-1"><a class="header" href="#contract-class-queries-1">Contract Class Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get class
let class = provider.get_class(
    block_id,
    class_hash
).await?;

// Get class at contract address
let class = provider.get_class_at(
    block_id,
    contract_address
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="event-queries-1"><a class="header" href="#event-queries-1">Event Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::core::types::{EventFilter, EventsPage};

let filter = EventFilter {
    from_block: Some(BlockId::Number(0)),
    to_block: Some(BlockId::Number(100)),
    address: Some(contract_address),
    keys: None,
};

let events: EventsPage = provider.get_events(
    filter,
    None,  // continuation_token
    100,   // chunk_size
).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="cheating-methods-3"><a class="header" href="#cheating-methods-3">Cheating Methods</a></h2>
<p>Beyond standard Provider methods, <code>CheatingProvider</code> offers testing-specific capabilities.</p>
<h3 id="time-manipulation-3"><a class="header" href="#time-manipulation-3">Time Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current timestamp
let timestamp = provider.get_timestamp().await?;

// Set specific timestamp
provider.set_timestamp(new_timestamp).await?;

// Increase time
provider.increase_time(seconds).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="block-manipulation-1"><a class="header" href="#block-manipulation-1">Block Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mine a single block
provider.mine_block().await?;

// Mine multiple blocks
provider.mine_blocks(count).await?;

// Set block interval
provider.set_block_interval(seconds).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="account-impersonation-1"><a class="header" href="#account-impersonation-1">Account Impersonation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Start impersonating an address
provider.start_prank(target_contract, impersonator).await?;

// Make calls as the impersonator
// All calls to target_contract will appear to come from impersonator

// Stop impersonating
provider.stop_prank(target_contract).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="balance-manipulation-3"><a class="header" href="#balance-manipulation-3">Balance Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set ETH balance
provider.set_balance(address, amount).await?;

// Deal tokens (if supported)
provider.deal(token_address, recipient, amount).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-manipulation-3"><a class="header" href="#storage-manipulation-3">Storage Manipulation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Write to storage
provider.store(
    contract_address,
    storage_key,
    value
).await?;

// Read from storage
let value = provider.load(
    contract_address,
    storage_key
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="snapshots-1"><a class="header" href="#snapshots-1">Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create snapshot
let snapshot_id = provider.snapshot().await?;

// Make changes...
contract.modify_state().await?;

// Restore to snapshot
provider.revert(snapshot_id).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="using-with-accounts-1"><a class="header" href="#using-with-accounts-1">Using with Accounts</a></h2>
<p>The middleware integrates seamlessly with Starknet accounts.</p>
<h3 id="account-creation-1"><a class="header" href="#account-creation-1">Account Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::accounts::{Account, SingleOwnerAccount};
use starknet::signers::LocalWallet;

// Create wallet
let signer = LocalWallet::from(private_key);

// Create account with the provider
let account = SingleOwnerAccount::new(
    provider.clone(),
    signer,
    account_address,
    chain_id,
);
<span class="boring">}</span></code></pre></pre>
<h3 id="signing-transactions-1"><a class="header" href="#signing-transactions-1">Signing Transactions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::accounts::Call;

// Prepare call
let call = Call {
    to: contract_address,
    selector: get_selector_from_name("transfer")?,
    calldata: vec![recipient, amount_low, amount_high],
};

// Execute through account
let result = account.execute(vec![call]).send().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="using-with-contract-bindings-1"><a class="header" href="#using-with-contract-bindings-1">Using with Contract Bindings</a></h2>
<p>The middleware works seamlessly with <code>cainome</code>-generated bindings.</p>
<h3 id="reading-from-contracts-1"><a class="header" href="#reading-from-contracts-1">Reading from Contracts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::erc_20_mintable_oz0::ERC20;

// Create contract instance
let token = ERC20::new(token_address, &amp;account);

// Read state (calls Provider methods)
let balance = token.balance_of(address).await?;
let total_supply = token.total_supply().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="writing-to-contracts-1"><a class="header" href="#writing-to-contracts-1">Writing to Contracts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Prepare transaction
let tx = token.transfer(recipient, amount);

// Execute (uses Account methods)
let result = tx.send().await?;

// Wait for confirmation
let receipt = result.wait_for_acceptance().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-management-1"><a class="header" href="#connection-management-1">Connection Management</a></h2>
<p>The middleware manages the underlying connection to Devnet.</p>
<h3 id="connection-configuration-1"><a class="header" href="#connection-configuration-1">Connection Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::middleware::Connection;

// Default configuration (automatic)
let connection = Connection::new()?;

// Custom port
let connection = Connection::with_port(5050)?;

// Custom URL
let connection = Connection::with_url("http://localhost:5050")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="health-checks-1"><a class="header" href="#health-checks-1">Health Checks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if Devnet is responsive
if provider.is_alive().await? {
    println!("Devnet is running");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<p>The middleware uses standard Starknet error types.</p>
<h3 id="common-errors-1"><a class="header" href="#common-errors-1">Common Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::providers::ProviderError;

match provider.get_block_with_tx_hashes(1000000).await {
    Ok(block) =&gt; {
        // Process block
    }
    Err(ProviderError::StarknetError(e)) =&gt; {
        // Starknet-specific error
        eprintln!("Starknet error: {:?}", e);
    }
    Err(e) =&gt; {
        // Other errors
        eprintln!("Provider error: {:?}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use Result types
async fn get_balance(
    provider: &amp;CheatingProvider,
    address: Felt,
) -&gt; Result&lt;Felt&gt; {
    let balance = provider.get_balance(address).await?;
    Ok(balance)
}

// Handle specific error cases
async fn safe_get_block(
    provider: &amp;CheatingProvider,
    block_num: u64,
) -&gt; Option&lt;Block&gt; {
    match provider.get_block_with_tx_hashes(block_num).await {
        Ok(block) =&gt; Some(block),
        Err(e) =&gt; {
            log::warn!("Failed to get block {}: {}", block_num, e);
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-patterns-1"><a class="header" href="#advanced-patterns-1">Advanced Patterns</a></h2>
<h3 id="concurrent-requests-1"><a class="header" href="#concurrent-requests-1">Concurrent Requests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::try_join;

// Execute multiple queries in parallel
let (balance, nonce, block) = try_join!(
    provider.get_balance(address),
    provider.get_nonce(BlockId::Pending, address),
    provider.block_number(),
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="retry-logic-1"><a class="header" href="#retry-logic-1">Retry Logic</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

async fn get_receipt_with_retry(
    provider: &amp;CheatingProvider,
    tx_hash: Felt,
    max_retries: u32,
) -&gt; Result&lt;TransactionReceipt&gt; {
    for attempt in 0..max_retries {
        match provider.get_transaction_receipt(tx_hash).await {
            Ok(receipt) =&gt; return Ok(receipt),
            Err(e) if attempt &lt; max_retries - 1 =&gt; {
                sleep(Duration::from_millis(100)).await;
                continue;
            }
            Err(e) =&gt; return Err(e.into()),
        }
    }
    unreachable!()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="polling-for-events-3"><a class="header" href="#polling-for-events-3">Polling for Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn watch_for_event(
    provider: &amp;CheatingProvider,
    contract: Felt,
    event_key: Felt,
) -&gt; Result&lt;Event&gt; {
    let mut last_block = provider.block_number().await?;
    
    loop {
        let current_block = provider.block_number().await?;
        
        if current_block &gt; last_block {
            let events = provider.get_events(
                EventFilter {
                    from_block: Some(BlockId::Number(last_block + 1)),
                    to_block: Some(BlockId::Number(current_block)),
                    address: Some(contract),
                    keys: Some(vec![vec![event_key]]),
                },
                None,
                100,
            ).await?;
            
            if let Some(event) = events.events.first() {
                return Ok(event.clone());
            }
            
            last_block = current_block;
        }
        
        sleep(Duration::from_millis(100)).await;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-middleware-1"><a class="header" href="#testing-with-middleware-1">Testing with Middleware</a></h2>
<h3 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use starkbiter_core::environment::Environment;

    #[tokio::test]
    async fn test_provider_queries() {
        let env = Environment::builder().build().await.unwrap();
        let provider = env.provider();
        
        let block_num = provider.block_number().await.unwrap();
        assert_eq!(block_num, 0);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_contract_interaction() {
    let env = Environment::builder().build().await?;
    let provider = env.provider();
    let account = env.create_account().await?;
    
    // Deploy contract
    let contract = deploy_test_contract(&amp;account).await?;
    
    // Interact through provider
    let call = Call {
        to: contract.address,
        selector: get_selector_from_name("set_value")?,
        calldata: vec![Felt::from(42u64)],
    };
    
    account.execute(vec![call]).send().await?;
    
    // Verify
    let value = contract.get_value().await?;
    assert_eq!(value, Felt::from(42u64));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_core/./environment.html">Environment</a> - Deep dive into Environment</li>
<li><a href="usage/starkbiter_core/./forking.html">Forking</a> - State forking from live networks</li>
<li><a href="usage/starkbiter_core/../usage/starkbiter_core/middleware.html">Usage Guide</a> - Detailed middleware API</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="starkbiter-engine-1"><a class="header" href="#starkbiter-engine-1">Starkbiter Engine</a></h1>
<p><code>starkbiter-engine</code> provides high-level abstractions for building complex, multi-agent simulations on Starknet. It sits on top of <code>starkbiter-core</code> and offers ergonomic interfaces for agent-based modeling.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>The engine crate enables you to:</p>
<ul>
<li><strong>Create Agents</strong> - Autonomous entities with custom behaviors</li>
<li><strong>Define Behaviors</strong> - Reusable action patterns for agents</li>
<li><strong>Build Worlds</strong> - Shared simulation environments</li>
<li><strong>Orchestrate Universes</strong> - Multiple parallel simulations</li>
<li><strong>Enable Messaging</strong> - Inter-agent communication</li>
</ul>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
starkbiter-engine = "0.1"
starkbiter-core = "0.1"
tokio = { version = "1.0", features = ["full"] }
</code></pre>
<h2 id="quick-start-2"><a class="header" href="#quick-start-2">Quick Start</a></h2>
<pre><pre class="playground"><code class="language-rust">use starkbiter_core::environment::Environment;
use starkbiter_engine::{Agent, Behavior, World};
use anyhow::Result;

// Define a behavior
struct TradingBehavior;

impl Behavior for TradingBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Agent logic here
        println!("Executing trading strategy");
        Ok(())
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Create environment
    let env = Environment::builder().build().await?;
    
    // Create world
    let world = World::new(env);
    
    // Create and add agents
    let trader = Agent::new("trader", TradingBehavior);
    world.add_agent(trader);
    
    // Run simulation
    world.run().await?;
    
    Ok(())
}</code></pre></pre>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="agents"><a class="header" href="#agents">Agents</a></h3>
<p>Agents are autonomous entities that execute behaviors. They can:</p>
<ul>
<li>React to blockchain events</li>
<li>Maintain internal state</li>
<li>Communicate with other agents</li>
<li>Execute transactions</li>
</ul>
<p><a href="usage/starkbiter_engine/./agents.html">Learn more about Agents â†’</a></p>
<h3 id="behaviors"><a class="header" href="#behaviors">Behaviors</a></h3>
<p>Behaviors define what agents do. They are:</p>
<ul>
<li>Reusable action patterns</li>
<li>Composable and modular</li>
<li>Event-driven or scheduled</li>
<li>Stateful or stateless</li>
</ul>
<p><a href="usage/starkbiter_engine/./behaviors.html">Learn more about Behaviors â†’</a></p>
<h3 id="worlds"><a class="header" href="#worlds">Worlds</a></h3>
<p>Worlds provide the simulation environment:</p>
<ul>
<li>Shared blockchain state</li>
<li>Agent coordination</li>
<li>Event distribution</li>
<li>Execution scheduling</li>
</ul>
<p><a href="usage/starkbiter_engine/./worlds_and_universes.html">Learn more about Worlds â†’</a></p>
<h3 id="universes"><a class="header" href="#universes">Universes</a></h3>
<p>Universes manage multiple worlds:</p>
<ul>
<li>Parallel simulations</li>
<li>Cross-world analytics</li>
<li>Resource management</li>
<li>Coordinated execution</li>
</ul>
<p><a href="usage/starkbiter_engine/./worlds_and_universes.html">Learn more about Universes â†’</a></p>
<h2 id="architecture-3"><a class="header" href="#architecture-3">Architecture</a></h2>
<pre><code>Universe
  â”œâ”€ World 1
  â”‚   â”œâ”€ Agent A (Behavior 1)
  â”‚   â”œâ”€ Agent B (Behavior 2)
  â”‚   â””â”€ Environment
  â””â”€ World 2
      â”œâ”€ Agent C (Behavior 3)
      â””â”€ Environment
</code></pre>
<h2 id="key-features-2"><a class="header" href="#key-features-2">Key Features</a></h2>
<h3 id="-agent-based-modeling"><a class="header" href="#-agent-based-modeling">ğŸ¤– Agent-Based Modeling</a></h3>
<p>Build sophisticated simulations with multiple autonomous agents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create different agent types
let liquidator = Agent::new("liquidator", LiquidatorBehavior);
let borrower = Agent::new("borrower", BorrowerBehavior);
let lender = Agent::new("lender", LenderBehavior);

// Add to world
world.add_agent(liquidator);
world.add_agent(borrower);
world.add_agent(lender);

// Agents interact autonomously
world.run().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="-event-driven-architecture"><a class="header" href="#-event-driven-architecture">ğŸ“¡ Event-Driven Architecture</a></h3>
<p>Agents react to blockchain events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for ArbitrageBehavior {
    async fn on_event(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        if event.name == "Swap" {
            // Check for arbitrage opportunity
            if let Some(profit) = self.check_arbitrage(&amp;event).await? {
                self.execute_arbitrage(profit).await?;
            }
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-inter-agent-communication"><a class="header" href="#-inter-agent-communication">ğŸ’¬ Inter-Agent Communication</a></h3>
<p>Agents can message each other:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Agent A sends message
world.send_message("agent-b", Message::RequestPrice).await?;

// Agent B receives and responds
impl Behavior for PriceOracleBehavior {
    async fn on_message(&amp;mut self, msg: Message) -&gt; Result&lt;()&gt; {
        match msg {
            Message::RequestPrice =&gt; {
                let price = self.get_current_price().await?;
                self.respond(Message::PriceUpdate(price)).await?;
            }
            _ =&gt; {}
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="-configuration-driven"><a class="header" href="#-configuration-driven">âš™ï¸ Configuration-Driven</a></h3>
<p>Define simulations in TOML:</p>
<pre><code class="language-toml"># config.toml
[environment]
chain_id = "0x534e5f5345504f4c4941"
block_time = 10

[agents.liquidator]
behavior = "LiquidatorBehavior"
threshold = 0.8

[agents.borrower]
behavior = "BorrowerBehavior"
risk_profile = "aggressive"
</code></pre>
<p><a href="usage/starkbiter_engine/./configuration.html">Learn more about Configuration â†’</a></p>
<h2 id="use-cases-3"><a class="header" href="#use-cases-3">Use Cases</a></h2>
<h3 id="defi-protocol-testing"><a class="header" href="#defi-protocol-testing">DeFi Protocol Testing</a></h3>
<p>Simulate complex DeFi scenarios:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Setup lending protocol
let world = create_lending_world().await?;

// Add diverse agents
world.add_agent(Agent::new("whale-lender", WhaleLender));
world.add_agent(Agent::new("retail-borrower", RetailBorrower));
world.add_agent(Agent::new("liquidator-bot", LiquidatorBot));
world.add_agent(Agent::new("oracle", PriceOracle));

// Simulate market conditions
world.run_for_blocks(1000).await?;

// Analyze results
let metrics = world.get_metrics();
assert!(metrics.protocol_health &gt; 0.95);
<span class="boring">}</span></code></pre></pre>
<h3 id="economic-modeling"><a class="header" href="#economic-modeling">Economic Modeling</a></h3>
<p>Model economic systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// AMM simulation
struct LiquidityProvider;
struct Arbitrageur;
struct RetailTrader;

let world = World::new(env);
world.add_agent(Agent::new("lp-1", LiquidityProvider));
world.add_agent(Agent::new("arb-1", Arbitrageur));
world.add_agent(Agent::new("trader-1", RetailTrader));

// Simulate trading activity
world.run().await?;

// Analyze pool dynamics
let pool_metrics = analyze_pool_behavior(&amp;world);
<span class="boring">}</span></code></pre></pre>
<h3 id="stress-testing"><a class="header" href="#stress-testing">Stress Testing</a></h3>
<p>Test protocol under extreme conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create stress test scenario
let world = setup_stress_test().await?;

// Add malicious agents
world.add_agent(Agent::new("attacker", FlashLoanAttacker));
world.add_agent(Agent::new("price-manipulator", PriceManipulator));

// Run attack scenarios
world.run_until(conditions_met).await?;

// Verify protocol safety
assert!(protocol_remains_solvent(&amp;world));
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-development"><a class="header" href="#strategy-development">Strategy Development</a></h3>
<p>Develop and test trading strategies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BacktestBehavior {
    strategy: TradingStrategy,
    performance: PerformanceTracker,
}

impl Behavior for BacktestBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        let signal = self.strategy.generate_signal(world).await?;
        
        if let Some(trade) = signal {
            let result = execute_trade(world, trade).await?;
            self.performance.record(result);
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="agent-lifecycle"><a class="header" href="#agent-lifecycle">Agent Lifecycle</a></h2>
<pre><code>Create â†’ Initialize â†’ Register Events â†’ Execute â†’ Cleanup
</code></pre>
<h3 id="creation"><a class="header" href="#creation">Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let agent = Agent::new("my-agent", MyBehavior::new());
<span class="boring">}</span></code></pre></pre>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for MyBehavior {
    async fn init(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Setup state, deploy contracts, etc.
        self.contract = deploy_contract(world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-registration"><a class="header" href="#event-registration">Event Registration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for MyBehavior {
    fn events(&amp;self) -&gt; Vec&lt;EventFilter&gt; {
        vec![
            EventFilter::contract_event(self.contract, "Transfer"),
            EventFilter::contract_event(self.contract, "Approval"),
        ]
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for MyBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Main agent logic
        self.process_events(world).await?;
        self.update_state(world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="behavior-patterns"><a class="header" href="#behavior-patterns">Behavior Patterns</a></h2>
<h3 id="reactive-behavior"><a class="header" href="#reactive-behavior">Reactive Behavior</a></h3>
<p>Respond to events:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for ReactiveBehavior {
    async fn on_event(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        match event.name.as_str() {
            "Swap" =&gt; self.handle_swap(event).await?,
            "Mint" =&gt; self.handle_mint(event).await?,
            _ =&gt; {}
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="scheduled-behavior"><a class="header" href="#scheduled-behavior">Scheduled Behavior</a></h3>
<p>Execute on schedule:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for ScheduledBehavior {
    fn schedule(&amp;self) -&gt; Schedule {
        Schedule::Every(Duration::from_secs(60)) // Every minute
    }
    
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Periodic action
        self.rebalance_portfolio(world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stateful-behavior"><a class="header" href="#stateful-behavior">Stateful Behavior</a></h3>
<p>Maintain state across executions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StatefulBehavior {
    state: AgentState,
    history: Vec&lt;Action&gt;,
}

impl Behavior for StatefulBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Use and update state
        let action = self.state.decide_action(world).await?;
        self.history.push(action.clone());
        self.execute_action(action, world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="messaging-system"><a class="header" href="#messaging-system">Messaging System</a></h2>
<h3 id="high-level-messaging"><a class="header" href="#high-level-messaging">High-Level Messaging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_engine::messager::{Messager, Message};

// Create messager
let messager = Messager::new();

// Agent A subscribes
messager.subscribe("agent-a", callback).await?;

// Agent B publishes
messager.publish("agent-a", Message::Data(value)).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-messages"><a class="header" href="#custom-messages">Custom Messages</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
enum CustomMessage {
    PriceUpdate(u64),
    TradeSignal { asset: String, action: Action },
    Alert(String),
}

// Send custom message
messager.publish("trader", CustomMessage::PriceUpdate(1000)).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="behavior-errors"><a class="header" href="#behavior-errors">Behavior Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for MyBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        self.risky_operation(world)
            .await
            .map_err(|e| anyhow!("Agent failed: {}", e))?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="world-level-error-handling"><a class="header" href="#world-level-error-handling">World-Level Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match world.run().await {
    Ok(_) =&gt; println!("Simulation completed successfully"),
    Err(e) =&gt; {
        eprintln!("Simulation failed: {}", e);
        world.dump_state().await?;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-agents"><a class="header" href="#testing-agents">Testing Agents</a></h2>
<h3 id="unit-tests-2"><a class="header" href="#unit-tests-2">Unit Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_agent_behavior() {
    let mut behavior = MyBehavior::new();
    let world = create_test_world().await;
    
    behavior.init(&amp;world).await.unwrap();
    behavior.execute(&amp;world).await.unwrap();
    
    assert_eq!(behavior.get_state(), expected_state);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests-2"><a class="header" href="#integration-tests-2">Integration Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_multi_agent_interaction() {
    let world = World::new(env);
    world.add_agent(Agent::new("agent-1", Behavior1));
    world.add_agent(Agent::new("agent-2", Behavior2));
    
    world.run_for_blocks(100).await.unwrap();
    
    let results = world.get_results();
    assert!(results.agents_interacted_correctly());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="parallel-agent-execution"><a class="header" href="#parallel-agent-execution">Parallel Agent Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Agents execute in parallel when possible
world.set_execution_mode(ExecutionMode::Parallel);
world.run().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations-1"><a class="header" href="#batch-operations-1">Batch Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for BatchBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Batch multiple operations
        let operations = self.prepare_batch();
        world.execute_batch(operations).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="1-keep-behaviors-focused"><a class="header" href="#1-keep-behaviors-focused">1. Keep Behaviors Focused</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Single responsibility
struct LiquidatorBehavior;

// Avoid: Too many responsibilities
struct GodBehavior;  // Don't do this!
<span class="boring">}</span></code></pre></pre>
<h3 id="2-use-composition"><a class="header" href="#2-use-composition">2. Use Composition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ComposedBehavior {
    price_oracle: PriceOracle,
    risk_manager: RiskManager,
    executor: TradeExecutor,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-handle-errors-gracefully"><a class="header" href="#3-handle-errors-gracefully">3. Handle Errors Gracefully</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for RobustBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        match self.try_execute(world).await {
            Ok(_) =&gt; Ok(()),
            Err(e) =&gt; {
                log::error!("Execution failed: {}", e);
                self.recover().await?;
                Ok(())
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-log-extensively"><a class="header" href="#4-log-extensively">4. Log Extensively</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for LoggingBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        log::info!("Starting execution");
        let result = self.do_work(world).await?;
        log::info!("Completed with result: {:?}", result);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_engine/./agents.html">Agents</a> - Deep dive into agents</li>
<li><a href="usage/starkbiter_engine/./behaviors.html">Behaviors</a> - Behavior patterns and examples</li>
<li><a href="usage/starkbiter_engine/./worlds_and_universes.html">Worlds and Universes</a> - Simulation environments</li>
<li><a href="usage/starkbiter_engine/./configuration.html">Configuration</a> - Configuration-driven simulations</li>
<li><a href="usage/starkbiter_engine/../../getting_started/examples.html">Examples</a> - Working examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="agents-1"><a class="header" href="#agents-1">Agents</a></h1>
<p>Agents are the core building blocks of simulations in Starkbiter Engine. They represent autonomous entities that can interact with the blockchain, respond to events, and communicate with other agents.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>An agent in Starkbiter is an autonomous entity that:</p>
<ul>
<li>Executes one or more behaviors</li>
<li>Maintains its own state</li>
<li>Reacts to blockchain events</li>
<li>Communicates with other agents through messaging</li>
<li>Has access to the blockchain through middleware</li>
</ul>
<h2 id="creating-agents"><a class="header" href="#creating-agents">Creating Agents</a></h2>
<h3 id="basic-agent"><a class="header" href="#basic-agent">Basic Agent</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_engine::Agent;

// Create agent with a behavior
let agent = Agent::new("my-agent", MyBehavior::new());
<span class="boring">}</span></code></pre></pre>
<h3 id="agent-with-multiple-behaviors"><a class="header" href="#agent-with-multiple-behaviors">Agent with Multiple Behaviors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut agent = Agent::new("multi-behavior-agent", PrimaryBehavior);
agent.add_behavior(SecondaryBehavior);
agent.add_behavior(MonitoringBehavior);
<span class="boring">}</span></code></pre></pre>
<h2 id="agent-structure"><a class="header" href="#agent-structure">Agent Structure</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Agent {
    pub id: String,
    client: Arc&lt;Middleware&gt;,
    messager: Messager,
    behaviors: Vec&lt;Box&lt;dyn StateMachine&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<ul>
<li><strong>ID</strong>: Unique identifier for the agent</li>
<li><strong>Client</strong>: Connection to the blockchain (middleware)</li>
<li><strong>Messager</strong>: For inter-agent communication</li>
<li><strong>Behaviors</strong>: List of behaviors the agent executes</li>
</ul>
<h2 id="agent-types"><a class="header" href="#agent-types">Agent Types</a></h2>
<h3 id="reactive-agents"><a class="header" href="#reactive-agents">Reactive Agents</a></h3>
<p>Respond to events on the blockchain:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EventReactiveAgent {
    target_contract: ContractAddress,
}

impl Behavior for EventReactiveAgent {
    async fn on_event(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        if event.from_address == self.target_contract {
            // React to events from specific contract
            self.handle_event(event).await?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="proactive-agents"><a class="header" href="#proactive-agents">Proactive Agents</a></h3>
<p>Take initiative based on strategy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ProactiveTrader {
    strategy: TradingStrategy,
}

impl Behavior for ProactiveTrader {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Generate trading signal
        if let Some(trade) = self.strategy.generate_signal().await? {
            self.execute_trade(trade).await?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="hybrid-agents"><a class="header" href="#hybrid-agents">Hybrid Agents</a></h3>
<p>Combine reactive and proactive behaviors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HybridAgent {
    reactive: EventHandler,
    proactive: StrategyExecutor,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="agent-lifecycle-1"><a class="header" href="#agent-lifecycle-1">Agent Lifecycle</a></h2>
<h3 id="1-creation"><a class="header" href="#1-creation">1. Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let agent = Agent::new("agent-id", behavior);
<span class="boring">}</span></code></pre></pre>
<h3 id="2-initialization"><a class="header" href="#2-initialization">2. Initialization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for MyBehavior {
    async fn init(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Deploy contracts, load state, etc.
        self.contract = deploy_my_contract(world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-execution"><a class="header" href="#3-execution">3. Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Agent added to world
world.add_agent(agent);

// World runs agents
world.run().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="4-cleanup"><a class="header" href="#4-cleanup">4. Cleanup</a></h3>
<p>Agents are automatically cleaned up when dropped.</p>
<h2 id="agent-communication"><a class="header" href="#agent-communication">Agent Communication</a></h2>
<h3 id="sending-messages"><a class="header" href="#sending-messages">Sending Messages</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for SenderAgent {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Send message to another agent
        world.send_message(
            "receiver-agent",
            Message::custom("price-update", 1000)
        ).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="receiving-messages"><a class="header" href="#receiving-messages">Receiving Messages</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for ReceiverAgent {
    async fn on_message(&amp;mut self, msg: Message) -&gt; Result&lt;()&gt; {
        match msg {
            Message::Custom { topic, data } if topic == "price-update" =&gt; {
                self.handle_price_update(data).await?;
            }
            _ =&gt; {}
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="agent-patterns"><a class="header" href="#agent-patterns">Agent Patterns</a></h2>
<h3 id="the-observer"><a class="header" href="#the-observer">The Observer</a></h3>
<p>Monitors contract state and reports:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ObserverAgent {
    watched_contracts: Vec&lt;ContractAddress&gt;,
    alert_threshold: u64,
}

impl Behavior for ObserverAgent {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        for contract in &amp;self.watched_contracts {
            let value = self.check_value(contract).await?;
            if value &gt; self.alert_threshold {
                world.send_alert(format!("Threshold exceeded: {}", value)).await?;
            }
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-executor"><a class="header" href="#the-executor">The Executor</a></h3>
<p>Executes transactions based on conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ExecutorAgent {
    pending_txs: Vec&lt;Transaction&gt;,
}

impl Behavior for ExecutorAgent {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        for tx in &amp;self.pending_txs {
            if self.should_execute(tx).await? {
                self.submit_transaction(tx, world).await?;
            }
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-coordinator"><a class="header" href="#the-coordinator">The Coordinator</a></h3>
<p>Coordinates actions between multiple agents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CoordinatorAgent {
    managed_agents: Vec&lt;String&gt;,
}

impl Behavior for CoordinatorAgent {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Send commands to managed agents
        for agent_id in &amp;self.managed_agents {
            world.send_message(
                agent_id,
                Message::Command(Action::Execute)
            ).await?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="1-single-responsibility"><a class="header" href="#1-single-responsibility">1. Single Responsibility</a></h3>
<p>Each agent should have a clear, focused purpose:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Focused agent
struct LiquidatorAgent;

// Avoid: Too many responsibilities
struct DoEverythingAgent; // Don't do this
<span class="boring">}</span></code></pre></pre>
<h3 id="2-state-management"><a class="header" href="#2-state-management">2. State Management</a></h3>
<p>Keep agent state minimal and well-organized:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WellOrganizedAgent {
    config: AgentConfig,
    state: AgentState,
    metrics: PerformanceMetrics,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-error-handling"><a class="header" href="#3-error-handling">3. Error Handling</a></h3>
<p>Handle errors gracefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for RobustAgent {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        match self.try_action(world).await {
            Ok(_) =&gt; Ok(()),
            Err(e) =&gt; {
                log::error!("Action failed: {}", e);
                self.recover().await?;
                Ok(())
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-logging"><a class="header" href="#4-logging">4. Logging</a></h3>
<p>Add comprehensive logging:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for LoggingAgent {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        log::info!("Agent {} starting execution", self.id);
        // ... execution logic
        log::debug!("Agent {} completed execution", self.id);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-agents-1"><a class="header" href="#testing-agents-1">Testing Agents</a></h2>
<h3 id="unit-tests-3"><a class="header" href="#unit-tests-3">Unit Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_agent_behavior() {
    let mut agent = TestAgent::new();
    let world = create_test_world().await;
    
    agent.init(&amp;world).await.unwrap();
    agent.execute(&amp;world).await.unwrap();
    
    assert_eq!(agent.action_count, 1);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests-3"><a class="header" href="#integration-tests-3">Integration Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_agent_interaction() {
    let world = World::new(env);
    let agent1 = Agent::new("agent-1", Behavior1);
    let agent2 = Agent::new("agent-2", Behavior2);
    
    world.add_agent(agent1);
    world.add_agent(agent2);
    
    world.run_for_blocks(10).await.unwrap();
    
    assert!(agents_interacted_correctly(&amp;world));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>See the <a href="usage/starkbiter_engine/../../getting_started/examples.html#token-minter-simulation">minter example</a> for a complete agent implementation.</p>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_engine/./behaviors.html">Behaviors</a> - Define agent actions</li>
<li><a href="usage/starkbiter_engine/./worlds_and_universes.html">Worlds and Universes</a> - Simulation environments</li>
<li><a href="usage/starkbiter_engine/./configuration.html">Configuration</a> - Configure agents via files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="behaviors-1"><a class="header" href="#behaviors-1">Behaviors</a></h1>
<p>Behaviors define what agents do in a simulation. They are the core logic that determines how agents interact with the blockchain, respond to events, and communicate with other agents.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>A Behavior is a trait that defines:</p>
<ul>
<li>How an agent initializes</li>
<li>How it responds to events</li>
<li>How it executes periodic actions</li>
<li>How it processes messages</li>
</ul>
<h2 id="the-behavior-trait"><a class="header" href="#the-behavior-trait">The Behavior Trait</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Behavior: Send + Sync {
    /// Initialize the behavior
    async fn init(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        Ok(())
    }
    
    /// Main execution logic
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt;;
    
    /// Handle blockchain events
    async fn on_event(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        Ok(())
    }
    
    /// Handle messages from other agents
    async fn on_message(&amp;mut self, message: Message) -&gt; Result&lt;()&gt; {
        Ok(())
    }
    
    /// Define which events to subscribe to
    fn events(&amp;self) -&gt; Vec&lt;EventFilter&gt; {
        vec![]
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-behaviors"><a class="header" href="#creating-behaviors">Creating Behaviors</a></h2>
<h3 id="simple-behavior"><a class="header" href="#simple-behavior">Simple Behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SimpleBehavior {
    counter: u64,
}

impl Behavior for SimpleBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        self.counter += 1;
        println!("Executed {} times", self.counter);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-driven-behavior"><a class="header" href="#event-driven-behavior">Event-Driven Behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EventDrivenBehavior {
    contract_address: Felt,
}

impl Behavior for EventDrivenBehavior {
    fn events(&amp;self) -&gt; Vec&lt;EventFilter&gt; {
        vec![
            EventFilter::contract_event(self.contract_address, "Transfer"),
        ]
    }
    
    async fn on_event(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        match event.name.as_str() {
            "Transfer" =&gt; self.handle_transfer(event).await?,
            _ =&gt; {}
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stateful-behavior-1"><a class="header" href="#stateful-behavior-1">Stateful Behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StatefulBehavior {
    state: AgentState,
    history: Vec&lt;Action&gt;,
}

impl Behavior for StatefulBehavior {
    async fn init(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        self.state = self.load_initial_state(world).await?;
        Ok(())
    }
    
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        let action = self.state.decide_next_action(world).await?;
        self.history.push(action.clone());
        self.execute_action(action, world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="behavior-patterns-1"><a class="header" href="#behavior-patterns-1">Behavior Patterns</a></h2>
<h3 id="the-trading-bot"><a class="header" href="#the-trading-bot">The Trading Bot</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TradingBotBehavior {
    strategy: Box&lt;dyn TradingStrategy&gt;,
    portfolio: Portfolio,
}

impl Behavior for TradingBotBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Get market data
        let prices = self.fetch_prices(world).await?;
        
        // Generate signal
        let signal = self.strategy.analyze(&amp;prices, &amp;self.portfolio).await?;
        
        // Execute if signal is strong enough
        if signal.strength &gt; 0.8 {
            self.execute_trade(world, signal.trade).await?;
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-liquidator"><a class="header" href="#the-liquidator">The Liquidator</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LiquidatorBehavior {
    lending_protocol: ContractAddress,
    min_profit: u64,
}

impl Behavior for LiquidatorBehavior {
    fn events(&amp;self) -&gt; Vec&lt;EventFilter&gt; {
        vec![
            EventFilter::contract_event(self.lending_protocol, "Borrow"),
            EventFilter::contract_event(self.lending_protocol, "PriceUpdate"),
        ]
    }
    
    async fn on_event(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        // Check for liquidation opportunities
        let positions = self.get_unhealthy_positions(event).await?;
        
        for position in positions {
            if let Some(profit) = self.calculate_profit(&amp;position).await? {
                if profit &gt; self.min_profit {
                    self.liquidate(position).await?;
                }
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-market-maker"><a class="header" href="#the-market-maker">The Market Maker</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MarketMakerBehavior {
    pool: ContractAddress,
    spread: f64,
    inventory: Inventory,
}

impl Behavior for MarketMakerBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Update quotes
        let mid_price = self.get_mid_price(world).await?;
        let bid = mid_price * (1.0 - self.spread);
        let ask = mid_price * (1.0 + self.spread);
        
        // Place orders
        self.place_limit_order(world, Side::Buy, bid).await?;
        self.place_limit_order(world, Side::Sell, ask).await?;
        
        // Rebalance inventory
        self.rebalance_if_needed(world).await?;
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-oracle"><a class="header" href="#the-oracle">The Oracle</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct OracleBehavior {
    price_feeds: Vec&lt;PriceFeed&gt;,
}

impl Behavior for OracleBehavior {
    async fn on_message(&amp;mut self, msg: Message) -&gt; Result&lt;()&gt; {
        match msg {
            Message::PriceRequest { asset } =&gt; {
                let price = self.fetch_price(&amp;asset).await?;
                self.respond(Message::PriceResponse { asset, price }).await?;
            }
            _ =&gt; {}
        }
        Ok(())
    }
    
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Periodically update prices
        for feed in &amp;self.price_feeds {
            let price = feed.fetch_latest().await?;
            world.broadcast(Message::PriceUpdate {
                asset: feed.asset.clone(),
                price,
            }).await?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="composing-behaviors"><a class="header" href="#composing-behaviors">Composing Behaviors</a></h2>
<h3 id="behavior-composition"><a class="header" href="#behavior-composition">Behavior Composition</a></h3>
<p>Combine multiple behaviors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ComposedBehavior {
    monitor: MonitoringBehavior,
    executor: ExecutionBehavior,
    reporter: ReportingBehavior,
}

impl Behavior for ComposedBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Execute in sequence
        self.monitor.execute(world).await?;
        self.executor.execute(world).await?;
        self.reporter.execute(world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-behavior"><a class="header" href="#conditional-behavior">Conditional Behavior</a></h3>
<p>Execute behaviors conditionally:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for ConditionalBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        if self.should_trade(world).await? {
            self.trading_behavior.execute(world).await?;
        } else {
            self.monitoring_behavior.execute(world).await?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-behaviors"><a class="header" href="#testing-behaviors">Testing Behaviors</a></h2>
<h3 id="unit-tests-4"><a class="header" href="#unit-tests-4">Unit Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_behavior_logic() {
    let mut behavior = MyBehavior::new();
    let world = create_mock_world();
    
    behavior.init(&amp;world).await.unwrap();
    behavior.execute(&amp;world).await.unwrap();
    
    assert_eq!(behavior.state, ExpectedState);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mock-world"><a class="header" href="#mock-world">Mock World</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MockWorld {
    // Minimal world for testing
}

impl MockWorld {
    fn new() -&gt; Self {
        // Create test environment
        Self {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="1-keep-behaviors-focused-1"><a class="header" href="#1-keep-behaviors-focused-1">1. Keep Behaviors Focused</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Single purpose
struct SwapExecutor;

// Avoid: Too many responsibilities
struct DoEverything; // Don't do this
<span class="boring">}</span></code></pre></pre>
<h3 id="2-make-behaviors-reusable"><a class="header" href="#2-make-behaviors-reusable">2. Make Behaviors Reusable</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ReusableBehavior&lt;S: Strategy&gt; {
    strategy: S,
}

// Can be used with different strategies
let behavior1 = ReusableBehavior { strategy: ConservativeStrategy };
let behavior2 = ReusableBehavior { strategy: AggressiveStrategy };
<span class="boring">}</span></code></pre></pre>
<h3 id="3-handle-errors-gracefully-1"><a class="header" href="#3-handle-errors-gracefully-1">3. Handle Errors Gracefully</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for RobustBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        self.try_execute(world).await.or_else(|e| {
            log::error!("Execution failed: {}", e);
            self.fallback(world)
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="4-add-logging"><a class="header" href="#4-add-logging">4. Add Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Behavior for LoggedBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        log::info!("Starting execution");
        let result = self.do_work(world).await;
        log::info!("Execution completed: {:?}", result);
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>See the <a href="usage/starkbiter_engine/../../getting_started/examples.html">examples</a> for complete behavior implementations.</p>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_engine/./agents.html">Agents</a> - Creating agents with behaviors</li>
<li><a href="usage/starkbiter_engine/./worlds_and_universes.html">Worlds and Universes</a> - Running simulations</li>
<li><a href="usage/starkbiter_engine/./configuration.html">Configuration</a> - Configuring behaviors</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="worlds-and-universes"><a class="header" href="#worlds-and-universes">Worlds and Universes</a></h1>
<p>Worlds and Universes are the containers and orchestrators for simulations in Starkbiter Engine.</p>
<h2 id="worlds-1"><a class="header" href="#worlds-1">Worlds</a></h2>
<p>A <strong>World</strong> represents a single simulation environment where agents interact with a shared blockchain state.</p>
<h3 id="creating-a-world"><a class="header" href="#creating-a-world">Creating a World</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_core::environment::Environment;
use starkbiter_engine::World;

let env = Environment::builder().build().await?;
let world = World::new(env);
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-agents"><a class="header" href="#adding-agents">Adding Agents</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>world.add_agent(Agent::new("trader", TradingBehavior));
world.add_agent(Agent::new("liquidator", LiquidatorBehavior));
world.add_agent(Agent::new("oracle", OracleBehavior));
<span class="boring">}</span></code></pre></pre>
<h3 id="running-simulations"><a class="header" href="#running-simulations">Running Simulations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Run until completion
world.run().await?;

// Run for specific number of blocks
world.run_for_blocks(1000).await?;

// Run until condition met
world.run_until(|w| w.condition_met()).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="universes-1"><a class="header" href="#universes-1">Universes</a></h2>
<p>A <strong>Universe</strong> manages multiple parallel worlds, enabling complex multi-world simulations and comparisons.</p>
<h3 id="creating-a-universe"><a class="header" href="#creating-a-universe">Creating a Universe</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_engine::Universe;

let universe = Universe::new();
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-worlds"><a class="header" href="#adding-worlds">Adding Worlds</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create worlds with different configurations
let world1 = create_conservative_world().await?;
let world2 = create_aggressive_world().await?;

universe.add_world("conservative", world1);
universe.add_world("aggressive", world2);
<span class="boring">}</span></code></pre></pre>
<h3 id="running-multiple-worlds"><a class="header" href="#running-multiple-worlds">Running Multiple Worlds</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Run all worlds in parallel
universe.run_all().await?;

// Compare results
let results = universe.compare_results();
<span class="boring">}</span></code></pre></pre>
<h2 id="world-api"><a class="header" href="#world-api">World API</a></h2>
<h3 id="state-queries-2"><a class="header" href="#state-queries-2">State Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current block
let block = world.get_block_number().await?;

// Get world state
let state = world.get_state();

// Get metrics
let metrics = world.get_metrics();
<span class="boring">}</span></code></pre></pre>
<h3 id="agent-management"><a class="header" href="#agent-management">Agent Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get agent by ID
let agent = world.get_agent("trader")?;

// List all agents
let agents = world.list_agents();

// Remove agent
world.remove_agent("trader")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="messaging"><a class="header" href="#messaging">Messaging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Send message to agent
world.send_message("receiver", Message::Data(value)).await?;

// Broadcast to all agents
world.broadcast(Message::Alert("Important".to_string())).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="use-cases-4"><a class="header" href="#use-cases-4">Use Cases</a></h2>
<h3 id="scenario-testing"><a class="header" href="#scenario-testing">Scenario Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test different scenarios in separate worlds
let bear_market = create_world_with_params(MarketCondition::Bear).await?;
let bull_market = create_world_with_params(MarketCondition::Bull).await?;

universe.add_world("bear", bear_market);
universe.add_world("bull", bull_market);

universe.run_all().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="parameter-sweeps"><a class="header" href="#parameter-sweeps">Parameter Sweeps</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test multiple parameter combinations
for gas_price in [10, 50, 100, 500] {
    let world = create_world_with_gas(gas_price).await?;
    universe.add_world(&amp;format!("gas-{}", gas_price), world);
}

universe.run_all().await?;
let optimal = universe.find_optimal_parameters();
<span class="boring">}</span></code></pre></pre>
<h3 id="ab-testing"><a class="header" href="#ab-testing">A/B Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compare strategy variations
let strategy_a = World::new(env1);
strategy_a.add_agent(Agent::new("trader", StrategyA));

let strategy_b = World::new(env2);
strategy_b.add_agent(Agent::new("trader", StrategyB));

universe.add_world("A", strategy_a);
universe.add_world("B", strategy_b);

universe.run_all().await?;
universe.compare_performance();
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_engine/./agents.html">Agents</a> - Creating agents</li>
<li><a href="usage/starkbiter_engine/./behaviors.html">Behaviors</a> - Defining behaviors</li>
<li><a href="usage/starkbiter_engine/./configuration.html">Configuration</a> - Configuration files</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h1>
<p>Starkbiter supports configuration-driven simulations using TOML files. This allows you to define simulations declaratively and separate configuration from code.</p>
<h2 id="configuration-file-structure"><a class="header" href="#configuration-file-structure">Configuration File Structure</a></h2>
<pre><code class="language-toml"># config.toml

[environment]
chain_id = "0x534e5f5345504f4c4941"  # Sepolia
block_time = 10                       # seconds
gas_price = 100000000000              # 100 gwei

[agents.liquidator]
behavior = "LiquidatorBehavior"
min_profit = 1000
check_interval = 60

[agents.trader]
behavior = "TradingBehavior"
initial_capital = 10000
risk_tolerance = 0.7

[agents.oracle]
behavior = "OracleBehavior"
update_frequency = 30
price_feeds = ["ETH/USD", "BTC/USD"]
</code></pre>
<h2 id="loading-configuration"><a class="header" href="#loading-configuration">Loading Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::Deserialize;
use std::fs;

#[derive(Deserialize)]
struct SimulationConfig {
    environment: EnvironmentConfig,
    agents: HashMap&lt;String, AgentConfig&gt;,
}

let config_str = fs::read_to_string("config.toml")?;
let config: SimulationConfig = toml::from_str(&amp;config_str)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="building-from-configuration"><a class="header" href="#building-from-configuration">Building from Configuration</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn build_from_config(config: SimulationConfig) -&gt; Result&lt;World&gt; {
    // Build environment
    let env = Environment::builder()
        .with_chain_id(Felt::from_hex(&amp;config.environment.chain_id)?)
        .with_block_time(config.environment.block_time)
        .build()
        .await?;
    
    let world = World::new(env);
    
    // Add agents
    for (id, agent_config) in config.agents {
        let behavior = create_behavior(&amp;agent_config)?;
        world.add_agent(Agent::new(&amp;id, behavior));
    }
    
    Ok(world)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="defi-protocol-testing-1"><a class="header" href="#defi-protocol-testing-1">DeFi Protocol Testing</a></h3>
<pre><code class="language-toml">[environment]
chain_id = "0x534e5f5345504f4c4941"
block_time = 10

[protocol]
pool_address = "0x..."
router_address = "0x..."

[agents.lender]
behavior = "LenderBehavior"
deposit_amount = 100000
target_apy = 0.05

[agents.borrower]
behavior = "BorrowerBehavior"
collateral_ratio = 1.5
max_leverage = 3

[agents.liquidator]
behavior = "LiquidatorBehavior"
min_profit = 500
</code></pre>
<h3 id="trading-simulation"><a class="header" href="#trading-simulation">Trading Simulation</a></h3>
<pre><code class="language-toml">[environment]
chain_id = "0x534e5f5345504f4c4941"

[agents.market_maker]
behavior = "MarketMakerBehavior"
spread = 0.003
inventory_target = 10000

[agents.arbitrageur]
behavior = "ArbitrageurBehavior"
min_profit_bps = 10
pools = ["pool1", "pool2", "pool3"]

[agents.retail_trader]
behavior = "RetailTraderBehavior"
trade_frequency = 120
average_size = 100
</code></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li><a href="usage/starkbiter_engine/./agents.html">Agents</a> - Creating agents</li>
<li><a href="usage/starkbiter_engine/./behaviors.html">Behaviors</a> - Defining behaviors</li>
<li><a href="usage/starkbiter_engine/../../getting_started/examples.html">Examples</a> - Working examples</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="starkbiter-cli-1"><a class="header" href="#starkbiter-cli-1">Starkbiter CLI</a></h1>
<p>The Starkbiter command-line interface provides tools for managing your projects and generating contract bindings.</p>
<h2 id="installation-3"><a class="header" href="#installation-3">Installation</a></h2>
<pre><code class="language-bash">cargo install starkbiter
</code></pre>
<h2 id="commands"><a class="header" href="#commands">Commands</a></h2>
<h3 id="bind---generate-contract-bindings"><a class="header" href="#bind---generate-contract-bindings"><code>bind</code> - Generate Contract Bindings</a></h3>
<p>Generate Rust bindings from Cairo contract JSON files using <code>cainome</code>.</p>
<pre><code class="language-bash">starkbiter bind [OPTIONS]
</code></pre>
<p><strong>Options:</strong></p>
<ul>
<li><code>--contracts-dir &lt;DIR&gt;</code> - Directory containing contract JSON files (default: <code>./contracts</code>)</li>
<li><code>--output-dir &lt;DIR&gt;</code> - Output directory for generated bindings (default: <code>./bindings/src</code>)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-bash"># Generate bindings for all contracts in ./contracts/
starkbiter bind

# Custom directories
starkbiter bind --contracts-dir ./my-contracts --output-dir ./src/bindings
</code></pre>
<p><strong>Contract Format:</strong></p>
<p>Your contract JSON files should be Sierra 1.0 compiled contracts with ABI:</p>
<pre><code class="language-json">{
  "sierra_program": [...],
  "contract_class_version": "0.1.0",
  "entry_points_by_type": {...},
  "abi": [...]
}
</code></pre>
<h3 id="init---initialize-a-new-project"><a class="header" href="#init---initialize-a-new-project"><code>init</code> - Initialize a New Project</a></h3>
<p><em>(Under development)</em></p>
<p>Create a new Starkbiter simulation project from a template.</p>
<pre><code class="language-bash">starkbiter init &lt;project-name&gt;
</code></pre>
<h3 id="--help---show-help"><a class="header" href="#--help---show-help"><code>--help</code> - Show Help</a></h3>
<p>Display help information:</p>
<pre><code class="language-bash">starkbiter --help
starkbiter bind --help
</code></pre>
<h2 id="workflow"><a class="header" href="#workflow">Workflow</a></h2>
<h3 id="1-compile-your-contracts"><a class="header" href="#1-compile-your-contracts">1. Compile Your Contracts</a></h3>
<p>First, compile your Cairo contracts to Sierra 1.0:</p>
<pre><code class="language-bash">scarb build
</code></pre>
<p>This generates JSON files in <code>target/dev/</code>.</p>
<h3 id="2-copy-contract-files"><a class="header" href="#2-copy-contract-files">2. Copy Contract Files</a></h3>
<p>Copy the contract JSON files to your project:</p>
<pre><code class="language-bash">mkdir contracts
cp target/dev/my_contract.contract_class.json contracts/
</code></pre>
<h3 id="3-generate-bindings"><a class="header" href="#3-generate-bindings">3. Generate Bindings</a></h3>
<p>Run the CLI to generate Rust bindings:</p>
<pre><code class="language-bash">starkbiter bind
</code></pre>
<p>This creates Rust files in <code>bindings/src/</code> with typed interfaces for your contracts.</p>
<h3 id="4-use-the-bindings"><a class="header" href="#4-use-the-bindings">4. Use the Bindings</a></h3>
<p>Import and use the generated bindings in your code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::bindings::my_contract::MyContract;

// Deploy
let contract = MyContract::deploy(&amp;account, constructor_args).await?;

// Call functions
let result = contract.my_function(args).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>A typical Starkbiter project structure:</p>
<pre><code>my-project/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ MyContract.json
â”‚   â””â”€â”€ MyToken.json
â”œâ”€â”€ bindings/
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ lib.rs
â”‚       â”œâ”€â”€ my_contract.rs
â”‚       â””â”€â”€ my_token.rs
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â””â”€â”€ behaviors/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â””â”€â”€ trading.rs
â””â”€â”€ config.toml
</code></pre>
<h2 id="cargotoml-setup"><a class="header" href="#cargotoml-setup">Cargo.toml Setup</a></h2>
<p>Add bindings crate as a dependency:</p>
<pre><code class="language-toml">[package]
name = "my-project"
version = "0.1.0"
edition = "2021"

[dependencies]
starkbiter-core = "0.1"
starkbiter-engine = "0.1"
my-bindings = { path = "./bindings" }
tokio = { version = "1.0", features = ["full"] }
anyhow = "1.0"
</code></pre>
<h2 id="tips-1"><a class="header" href="#tips-1">Tips</a></h2>
<h3 id="automatic-regeneration"><a class="header" href="#automatic-regeneration">Automatic Regeneration</a></h3>
<p>Use a build script or file watcher to regenerate bindings when contracts change:</p>
<pre><code class="language-bash"># Using cargo-watch
cargo watch -x "run --bin starkbiter -- bind"
</code></pre>
<h3 id="cicd-integration"><a class="header" href="#cicd-integration">CI/CD Integration</a></h3>
<p>Add to your CI pipeline:</p>
<pre><code class="language-yaml"># .github/workflows/ci.yml
- name: Generate bindings
  run: starkbiter bind
  
- name: Check bindings are up to date
  run: git diff --exit-code bindings/
</code></pre>
<h3 id="multiple-contract-directories"><a class="header" href="#multiple-contract-directories">Multiple Contract Directories</a></h3>
<p>Generate bindings from multiple directories:</p>
<pre><code class="language-bash">starkbiter bind --contracts-dir ./core-contracts
starkbiter bind --contracts-dir ./periphery-contracts
</code></pre>
<h2 id="troubleshooting-4"><a class="header" href="#troubleshooting-4">Troubleshooting</a></h2>
<h3 id="binding-generation-fails"><a class="header" href="#binding-generation-fails">Binding Generation Fails</a></h3>
<p><strong>Error:</strong> "Failed to parse contract JSON"</p>
<p><strong>Solution:</strong> Ensure contracts are compiled with compatible Sierra version:</p>
<pre><code class="language-bash">scarb build --release
</code></pre>
<h3 id="missing-dependencies-1"><a class="header" href="#missing-dependencies-1">Missing Dependencies</a></h3>
<p><strong>Error:</strong> "cainome not found"</p>
<p><strong>Solution:</strong> The CLI includes cainome, but ensure you have it in your dependencies:</p>
<pre><code class="language-toml">[dependencies]
cainome = "0.3"
</code></pre>
<h3 id="import-errors"><a class="header" href="#import-errors">Import Errors</a></h3>
<p><strong>Error:</strong> "Cannot find module"</p>
<p><strong>Solution:</strong> Check your <code>lib.rs</code> in bindings crate includes the generated modules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod my_contract;
pub mod my_token;
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h2>
<ul>
<li><a href="usage/../getting_started/quick_start.html">Quick Start</a> - Build your first simulation</li>
<li><a href="usage/../getting_started/examples.html">Examples</a> - See bindings in action</li>
<li><a href="usage/./starkbiter_bindings.html">Starkbiter Bindings</a> - Pre-generated bindings</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="starkbiter-macros-1"><a class="header" href="#starkbiter-macros-1">Starkbiter Macros</a></h1>
<p><code>starkbiter-macros</code> provides procedural macros to reduce boilerplate and improve ergonomics when building simulations.</p>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>The macros crate simplifies common patterns:</p>
<ul>
<li>Behavior derivation</li>
<li>Agent configuration</li>
<li>Event handling</li>
<li>Message routing</li>
</ul>
<h2 id="installation-4"><a class="header" href="#installation-4">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
starkbiter-macros = "0.1"
</code></pre>
<h2 id="available-macros"><a class="header" href="#available-macros">Available Macros</a></h2>
<h3 id="behavior"><a class="header" href="#behavior"><code>#[behavior]</code></a></h3>
<p>Automatically implement the <code>Behavior</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_macros::behavior;

#[behavior]
struct MyBehavior {
    counter: u64,
}

// The macro generates the Behavior implementation
impl MyBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        self.counter += 1;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="agent"><a class="header" href="#agent"><code>#[agent]</code></a></h3>
<p>Configure agent with derive macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_macros::agent;

#[agent(
    id = "trader",
    events = ["Transfer", "Swap"]
)]
struct TradingAgent {
    strategy: Strategy,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event_handler"><a class="header" href="#event_handler"><code>#[event_handler]</code></a></h3>
<p>Simplify event handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_macros::event_handler;

#[event_handler]
impl MyBehavior {
    #[on_event("Transfer")]
    async fn handle_transfer(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        // Handle transfer event
        Ok(())
    }
    
    #[on_event("Swap")]
    async fn handle_swap(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        // Handle swap event
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<h3 id="complete-agent-with-macros"><a class="header" href="#complete-agent-with-macros">Complete Agent with Macros</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_macros::{behavior, event_handler};
use starkbiter_engine::Behavior;

#[behavior]
#[event_handler]
struct TradingBot {
    position: Position,
    profit: u64,
}

impl TradingBot {
    #[on_event("PriceUpdate")]
    async fn on_price_update(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        let price = parse_price(&amp;event)?;
        self.update_position(price).await?;
        Ok(())
    }
    
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Main execution logic
        self.check_exit_conditions(world).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-macro"><a class="header" href="#configuration-macro">Configuration Macro</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_macros::config;

#[config]
struct SimConfig {
    #[env]
    chain_id: String,
    
    #[agent]
    trader: TraderConfig,
    
    #[agent]
    liquidator: LiquidatorConfig,
}

// Automatically load from TOML
let config = SimConfig::from_file("config.toml")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<h3 id="reduced-boilerplate"><a class="header" href="#reduced-boilerplate">Reduced Boilerplate</a></h3>
<p><strong>Without macros:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBehavior;

impl Behavior for MyBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Logic
        Ok(())
    }
    
    async fn on_event(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        match event.name.as_str() {
            "Transfer" =&gt; self.handle_transfer(event).await?,
            "Swap" =&gt; self.handle_swap(event).await?,
            _ =&gt; {}
        }
        Ok(())
    }
    
    fn events(&amp;self) -&gt; Vec&lt;EventFilter&gt; {
        vec![
            EventFilter::name("Transfer"),
            EventFilter::name("Swap"),
        ]
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>With macros:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[behavior]
#[event_handler]
struct MyBehavior;

impl MyBehavior {
    #[on_event("Transfer")]
    async fn handle_transfer(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        // Logic
        Ok(())
    }
    
    #[on_event("Swap")]
    async fn handle_swap(&amp;mut self, event: Event) -&gt; Result&lt;()&gt; {
        // Logic
        Ok(())
    }
    
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h3>
<p>Macros provide compile-time checks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[behavior]
struct TypedBehavior {
    #[validate(min = 0, max = 100)]
    percentage: u8,
}

// Compile error if validation fails
<span class="boring">}</span></code></pre></pre>
<h3 id="better-ide-support"><a class="header" href="#better-ide-support">Better IDE Support</a></h3>
<p>Macros generate code that IDEs understand, providing better autocomplete and error messages.</p>
<h2 id="advanced-usage"><a class="header" href="#advanced-usage">Advanced Usage</a></h2>
<h3 id="custom-attributes"><a class="header" href="#custom-attributes">Custom Attributes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[behavior(
    name = "MyBehavior",
    description = "A sophisticated trading bot"
)]
struct MyBehavior {
    #[state]
    position: Position,
    
    #[metric]
    profit: u64,
    
    #[config]
    risk_tolerance: f64,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[behavior]
struct DebugBehavior {
    #[cfg(debug_assertions)]
    debug_info: DebugInfo,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ul>
<li><a href="usage/./starkbiter_core/index.html">Starkbiter Core</a> - Core functionality</li>
<li><a href="usage/./starkbiter_engine/index.html">Starkbiter Engine</a> - Agent-based simulations</li>
<li><a href="usage/../getting_started/examples.html">Examples</a> - See macros in action</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="starkbiter-bindings-1"><a class="header" href="#starkbiter-bindings-1">Starkbiter Bindings</a></h1>
<p><code>starkbiter-bindings</code> provides pre-generated Rust bindings for common Starknet contracts, making it easy to interact with standard protocols in your simulations.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>The bindings crate includes:</p>
<ul>
<li>ERC20 token contracts</li>
<li>Account contracts (Argent, OpenZeppelin)</li>
<li>DEX protocols (Ekubo)</li>
<li>Test utilities</li>
</ul>
<h2 id="installation-5"><a class="header" href="#installation-5">Installation</a></h2>
<pre><code class="language-toml">[dependencies]
starkbiter-bindings = "0.1"
</code></pre>
<h2 id="available-bindings"><a class="header" href="#available-bindings">Available Bindings</a></h2>
<h3 id="erc20-tokens"><a class="header" href="#erc20-tokens">ERC20 Tokens</a></h3>
<h4 id="standard-erc20"><a class="header" href="#standard-erc20">Standard ERC20</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::erc_20_mintable_oz0::ERC20;
use starknet::core::types::Felt;

// Deploy new token
let token = ERC20::deploy(
    &amp;account,
    "My Token",          // name
    "MTK",              // symbol
    18,                 // decimals
    Felt::from(1_000_000u64),  // initial supply
    owner_address,      // recipient
).await?;

// Transfer tokens
token.transfer(recipient, amount).await?;

// Check balance
let balance = token.balance_of(address).await?;

// Approve spending
token.approve(spender, amount).await?;

// Check allowance
let allowance = token.allowance(owner, spender).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="account-contracts"><a class="header" href="#account-contracts">Account Contracts</a></h3>
<h4 id="argent-account"><a class="header" href="#argent-account">Argent Account</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::argent_account::ArgentAccount;

let account = ArgentAccount::new(account_address, &amp;provider);

// Execute transaction
account.execute(calls).await?;

// Get account info
let owner = account.get_owner().await?;
<span class="boring">}</span></code></pre></pre>
<h4 id="openzeppelin-account"><a class="header" href="#openzeppelin-account">OpenZeppelin Account</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::open_zeppelin_account::OZAccount;

let account = OZAccount::new(account_address, &amp;provider);
<span class="boring">}</span></code></pre></pre>
<h3 id="dex-protocols"><a class="header" href="#dex-protocols">DEX Protocols</a></h3>
<h4 id="ekubo-core"><a class="header" href="#ekubo-core">Ekubo Core</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::ekubo_core::EkuboCore;

let ekubo = EkuboCore::new(ekubo_address, &amp;account);

// Get pool info
let pool = ekubo.get_pool(token0, token1, fee).await?;

// Swap tokens
ekubo.swap(
    token_in,
    token_out,
    amount,
    min_amount_out,
    recipient
).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="test-contracts"><a class="header" href="#test-contracts">Test Contracts</a></h3>
<h4 id="counter"><a class="header" href="#counter">Counter</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::contracts_counter::Counter;

let counter = Counter::deploy(&amp;account).await?;

counter.increment().await?;
let value = counter.get_value().await?;
assert_eq!(value, Felt::from(1u64));
<span class="boring">}</span></code></pre></pre>
<h4 id="uservalues"><a class="header" href="#uservalues">UserValues</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starkbiter_bindings::contracts_user_values::UserValues;

let contract = UserValues::deploy(&amp;account).await?;

contract.set_value(key, value).await?;
let retrieved = contract.get_value(key).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="common-patterns-3"><a class="header" href="#common-patterns-3">Common Patterns</a></h2>
<h3 id="deploy-and-initialize-token"><a class="header" href="#deploy-and-initialize-token">Deploy and Initialize Token</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn setup_token(account: &amp;Account) -&gt; Result&lt;ERC20&gt; {
    let token = ERC20::deploy(
        account,
        "Test Token",
        "TEST",
        18,
        Felt::from(1_000_000_000u64),
        account.address(),
    ).await?;
    
    Ok(token)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="transfer-between-accounts"><a class="header" href="#transfer-between-accounts">Transfer Between Accounts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn transfer_tokens(
    token: &amp;ERC20,
    from: &amp;Account,
    to: Felt,
    amount: Felt
) -&gt; Result&lt;()&gt; {
    token.transfer(to, amount).await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="approve-and-transfer-from"><a class="header" href="#approve-and-transfer-from">Approve and Transfer From</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Owner approves spender
token.approve(spender_address, amount).await?;

// Spender transfers from owner
let spender_token = ERC20::new(token.address(), &amp;spender_account);
spender_token.transfer_from(
    owner_address,
    recipient,
    amount
).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-simulations"><a class="header" href="#integration-with-simulations">Integration with Simulations</a></h2>
<h3 id="token-distribution-agent"><a class="header" href="#token-distribution-agent">Token Distribution Agent</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TokenDistributor {
    token: ERC20,
    recipients: Vec&lt;Felt&gt;,
}

impl Behavior for TokenDistributor {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        let amount = Felt::from(100u64);
        
        for recipient in &amp;self.recipients {
            self.token.transfer(*recipient, amount).await?;
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="dex-trader-agent"><a class="header" href="#dex-trader-agent">DEX Trader Agent</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DexTrader {
    ekubo: EkuboCore,
    token_in: Felt,
    token_out: Felt,
}

impl Behavior for DexTrader {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        let amount = Felt::from(1000u64);
        
        self.ekubo.swap(
            self.token_in,
            self.token_out,
            amount,
            Felt::ZERO,
            world.account().address()
        ).await?;
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-custom-bindings"><a class="header" href="#creating-custom-bindings">Creating Custom Bindings</a></h2>
<p>To generate bindings for your own contracts:</p>
<ol>
<li>Compile your Cairo contract to Sierra 1.0</li>
<li>Place the JSON file in <code>contracts/</code></li>
<li>Run <code>starkbiter bind</code></li>
</ol>
<pre><code class="language-bash"># Copy contract
cp target/dev/my_contract.contract_class.json contracts/

# Generate bindings
starkbiter bind

# Use in code
use crate::bindings::my_contract::MyContract;
</code></pre>
<p>See <a href="usage/./starkbiter_cli.html">Starkbiter CLI</a> for more details.</p>
<h2 id="contract-addresses"><a class="header" href="#contract-addresses">Contract Addresses</a></h2>
<p>The bindings work with any deployment. You specify addresses when creating instances:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use with mainnet deployment
let usdc = ERC20::new(
    Felt::from_hex("0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8")?,
    &amp;account
);

// Or with your own deployment
let token = ERC20::deploy(&amp;account, ...).await?;
let token_address = token.address();
<span class="boring">}</span></code></pre></pre>
<h2 id="type-safety-1"><a class="header" href="#type-safety-1">Type Safety</a></h2>
<p>All bindings provide type-safe interfaces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile-time type checking
let balance: Felt = token.balance_of(address).await?;

// Method signatures match contract ABI
token.transfer(recipient: Felt, amount: Felt).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;

async fn safe_transfer(token: &amp;ERC20, to: Felt, amount: Felt) -&gt; Result&lt;()&gt; {
    match token.transfer(to, amount).await {
        Ok(_) =&gt; {
            println!("Transfer successful");
            Ok(())
        }
        Err(e) =&gt; {
            eprintln!("Transfer failed: {}", e);
            Err(e.into())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-with-bindings"><a class="header" href="#testing-with-bindings">Testing with Bindings</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_erc20_transfer() {
    let env = Environment::builder().build().await?;
    let account = env.create_account().await?;
    
    // Deploy token
    let token = ERC20::deploy(
        &amp;account,
        "Test",
        "TST",
        18,
        Felt::from(1_000_000u64),
        account.address(),
    ).await?;
    
    // Test transfer
    let recipient = Felt::from(999u64);
    let amount = Felt::from(1000u64);
    
    token.transfer(recipient, amount).await?;
    
    let balance = token.balance_of(recipient).await?;
    assert_eq!(balance, amount);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li><a href="usage/./starkbiter_cli.html">Starkbiter CLI</a> - Generate custom bindings</li>
<li><a href="usage/../getting_started/quick_start.html">Quick Start</a> - Use bindings in simulations</li>
<li><a href="usage/../getting_started/examples.html">Examples</a> - See bindings in action</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h1>
<p>This chapter covers advanced testing strategies for smart contracts and DeFi protocols using Starkbiter.</p>
<h2 id="unit-testing-1"><a class="header" href="#unit-testing-1">Unit Testing</a></h2>
<p>Test individual contract functions in isolation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_token_transfer() {
    let env = Environment::builder().build().await?;
    let account = env.create_account().await?;
    
    let token = deploy_token(&amp;account).await?;
    let recipient = Felt::from(999u64);
    let amount = Felt::from(1000u64);
    
    token.transfer(recipient, amount).await?;
    
    let balance = token.balance_of(recipient).await?;
    assert_eq!(balance, amount);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-testing-1"><a class="header" href="#integration-testing-1">Integration Testing</a></h2>
<p>Test interactions between multiple contracts.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_swap_integration() {
    let env = Environment::builder().build().await?;
    let account = env.create_account().await?;
    
    // Deploy all components
    let token_a = deploy_token(&amp;account, "TokenA").await?;
    let token_b = deploy_token(&amp;account, "TokenB").await?;
    let pool = deploy_pool(&amp;account, token_a.address(), token_b.address()).await?;
    let router = deploy_router(&amp;account, pool.address()).await?;
    
    // Test the full flow
    token_a.approve(router.address(), amount).await?;
    router.swap(token_a.address(), token_b.address(), amount).await?;
    
    // Verify results
    let balance_b = token_b.balance_of(account.address()).await?;
    assert!(balance_b &gt; Felt::ZERO);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="fuzzing"><a class="header" href="#fuzzing">Fuzzing</a></h2>
<p>Test with random inputs to find edge cases.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

#[tokio::test]
async fn fuzz_token_operations() {
    proptest!(|(amount in 1u64..1_000_000u64)| {
        tokio_test::block_on(async {
            let env = Environment::builder().build().await.unwrap();
            let account = env.create_account().await.unwrap();
            let token = deploy_token(&amp;account).await.unwrap();
            
            // Should never panic
            let _ = token.transfer(recipient, Felt::from(amount)).await;
        });
    });
}
<span class="boring">}</span></code></pre></pre>
<h2 id="invariant-testing"><a class="header" href="#invariant-testing">Invariant Testing</a></h2>
<p>Test that certain properties always hold.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_total_supply_invariant() {
    let env = Environment::builder().build().await?;
    let account1 = env.create_account().await?;
    let account2 = env.create_account().await?;
    
    let token = deploy_token(&amp;account1).await?;
    let initial_supply = token.total_supply().await?;
    
    // Perform many operations
    for _ in 0..100 {
        token.transfer(account2.address(), Felt::from(100u64)).await?;
    }
    
    // Invariant: total supply never changes
    let final_supply = token.total_supply().await?;
    assert_eq!(initial_supply, final_supply);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="time-based-testing-3"><a class="header" href="#time-based-testing-3">Time-Based Testing</a></h2>
<p>Test time-dependent behavior.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_timelock() {
    let env = Environment::builder().build().await?;
    let account = env.create_account().await?;
    
    let timelock = deploy_timelock(&amp;account, 86400).await?; // 24 hours
    
    // Should fail before timelock
    assert!(timelock.withdraw().await.is_err());
    
    // Fast forward
    env.increase_time(86400).await?;
    env.mine_block().await?;
    
    // Should succeed after timelock
    assert!(timelock.withdraw().await.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="snapshot-testing"><a class="header" href="#snapshot-testing">Snapshot Testing</a></h2>
<p>Use snapshots to test multiple scenarios from the same starting state.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_multiple_scenarios() {
    let env = Environment::builder().build().await?;
    let (token, pool) = setup_defi_protocol(&amp;env).await?;
    
    // Take snapshot
    let snapshot = env.snapshot().await?;
    
    // Test scenario 1: Normal usage
    test_normal_usage(&amp;env, &amp;pool).await?;
    env.restore(snapshot).await?;
    
    // Test scenario 2: Extreme volatility
    test_high_volatility(&amp;env, &amp;pool).await?;
    env.restore(snapshot).await?;
    
    // Test scenario 3: Attack
    test_flash_loan_attack(&amp;env, &amp;pool).await?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="stress-testing-1"><a class="header" href="#stress-testing-1">Stress Testing</a></h2>
<p>Test protocol under extreme conditions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn stress_test_lending_protocol() {
    let env = Environment::builder().build().await?;
    let protocol = deploy_lending_protocol(&amp;env).await?;
    
    // Simulate high load
    let mut handles = vec![];
    for i in 0..100 {
        let env = env.clone();
        let protocol = protocol.clone();
        
        handles.push(tokio::spawn(async move {
            let account = env.create_account().await.unwrap();
            protocol.borrow(&amp;account, amount).await
        }));
    }
    
    // Wait for all operations
    for handle in handles {
        handle.await.unwrap()?;
    }
    
    // Protocol should still be solvent
    assert!(protocol.is_solvent().await?);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-19"><a class="header" href="#next-steps-19">Next Steps</a></h2>
<ul>
<li><a href="advanced/./simulation_techniques.html">Simulation Techniques</a> - Advanced simulation patterns</li>
<li><a href="advanced/./anomaly_detection.html">Anomaly Detection</a> - Detecting unusual behavior</li>
<li><a href="advanced/./performance.html">Performance Optimization</a> - Optimizing your tests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="simulation-techniques"><a class="header" href="#simulation-techniques">Simulation Techniques</a></h1>
<p>Advanced techniques for building realistic and effective simulations with Starkbiter.</p>
<h2 id="agent-based-modeling"><a class="header" href="#agent-based-modeling">Agent-Based Modeling</a></h2>
<h3 id="heterogeneous-agents"><a class="header" href="#heterogeneous-agents">Heterogeneous Agents</a></h3>
<p>Create agents with different behaviors and strategies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conservative trader
let conservative = Agent::new("conservative", ConservativeBehavior {
    risk_tolerance: 0.3,
    trade_frequency: Duration::from_secs(3600),
});

// Aggressive trader
let aggressive = Agent::new("aggressive", AggressiveBehavior {
    risk_tolerance: 0.9,
    trade_frequency: Duration::from_secs(60),
});

world.add_agent(conservative);
world.add_agent(aggressive);
<span class="boring">}</span></code></pre></pre>
<h3 id="adaptive-agents"><a class="header" href="#adaptive-agents">Adaptive Agents</a></h3>
<p>Agents that learn and adapt:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AdaptiveBehavior {
    strategy: Box&lt;dyn Strategy&gt;,
    performance: PerformanceTracker,
}

impl Behavior for AdaptiveBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Execute strategy
        let result = self.strategy.execute(world).await?;
        
        // Track performance
        self.performance.record(result);
        
        // Adapt if performance is poor
        if self.performance.is_underperforming() {
            self.strategy = self.select_better_strategy();
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="economic-modeling-1"><a class="header" href="#economic-modeling-1">Economic Modeling</a></h2>
<h3 id="supply-and-demand"><a class="header" href="#supply-and-demand">Supply and Demand</a></h3>
<p>Model market dynamics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MarketSimulation {
    suppliers: Vec&lt;Agent&gt;,
    consumers: Vec&lt;Agent&gt;,
    price_discovery: PriceDiscovery,
}

impl MarketSimulation {
    async fn simulate(&amp;mut self, blocks: u64) -&gt; Result&lt;PriceHistory&gt; {
        for _ in 0..blocks {
            // Suppliers offer
            let supply = self.aggregate_supply().await?;
            
            // Consumers bid
            let demand = self.aggregate_demand().await?;
            
            // Clear market
            let price = self.price_discovery.clear_market(supply, demand);
            
            // Execute trades
            self.execute_at_price(price).await?;
        }
        
        Ok(self.price_discovery.history())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="liquidity-modeling"><a class="header" href="#liquidity-modeling">Liquidity Modeling</a></h3>
<p>Simulate realistic liquidity conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LiquidityProvider {
    target_tvl: u64,
    rebalance_threshold: f64,
}

impl Behavior for LiquidityProvider {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        let current_tvl = self.get_tvl(world).await?;
        let imbalance = (current_tvl as f64 - self.target_tvl as f64).abs()
            / self.target_tvl as f64;
        
        if imbalance &gt; self.rebalance_threshold {
            self.rebalance(world, current_tvl).await?;
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="monte-carlo-simulation"><a class="header" href="#monte-carlo-simulation">Monte Carlo Simulation</a></h2>
<p>Run many simulations with random parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn monte_carlo_analysis(
    scenarios: usize,
) -&gt; Result&lt;Statistics&gt; {
    let mut results = vec![];
    
    for i in 0..scenarios {
        // Create environment with random seed
        let env = Environment::builder()
            .with_seed(i as u64)
            .build()
            .await?;
        
        // Run simulation
        let outcome = run_simulation(env).await?;
        results.push(outcome);
    }
    
    // Analyze results
    Ok(Statistics::from_results(results))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="scenario-analysis"><a class="header" href="#scenario-analysis">Scenario Analysis</a></h2>
<h3 id="best-case--worst-case"><a class="header" href="#best-case--worst-case">Best Case / Worst Case</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn scenario_analysis() -&gt; Result&lt;ScenarioResults&gt; {
    let universe = Universe::new();
    
    // Best case
    let best = create_optimistic_world().await?;
    universe.add_world("best", best);
    
    // Expected case
    let expected = create_realistic_world().await?;
    universe.add_world("expected", expected);
    
    // Worst case
    let worst = create_pessimistic_world().await?;
    universe.add_world("worst", worst);
    
    universe.run_all().await?;
    
    Ok(universe.compare_outcomes())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parameter-sweeps-1"><a class="header" href="#parameter-sweeps-1">Parameter Sweeps</a></h3>
<p>Test across parameter ranges:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn parameter_sweep() -&gt; Result&lt;HeatMap&gt; {
    let mut results = HeatMap::new();
    
    for fee in [0.001, 0.003, 0.005, 0.01] {
        for slippage in [0.001, 0.005, 0.01, 0.05] {
            let env = Environment::builder().build().await?;
            let protocol = deploy_with_params(&amp;env, fee, slippage).await?;
            
            let profit = simulate_trading(&amp;protocol).await?;
            results.insert((fee, slippage), profit);
        }
    }
    
    Ok(results)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="time-series-analysis"><a class="header" href="#time-series-analysis">Time Series Analysis</a></h2>
<h3 id="price-processes"><a class="header" href="#price-processes">Price Processes</a></h3>
<p>Simulate realistic price movements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GeometricBrownianMotion {
    mu: f64,      // drift
    sigma: f64,   // volatility
    dt: f64,      // time step
}

impl GeometricBrownianMotion {
    fn simulate(&amp;self, steps: usize, initial_price: f64) -&gt; Vec&lt;f64&gt; {
        let mut prices = vec![initial_price];
        let mut rng = thread_rng();
        
        for _ in 0..steps {
            let last_price = prices.last().unwrap();
            let dw = Normal::new(0.0, (self.dt).sqrt()).unwrap().sample(&amp;mut rng);
            let drift = self.mu * self.dt;
            let diffusion = self.sigma * dw;
            let next_price = last_price * ((drift + diffusion).exp());
            prices.push(next_price);
        }
        
        prices
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-driven-updates"><a class="header" href="#event-driven-updates">Event-Driven Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PriceOracle {
    gbm: GeometricBrownianMotion,
    current_price: f64,
}

impl Behavior for PriceOracle {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Update price
        let new_price = self.gbm.step(self.current_price);
        self.current_price = new_price;
        
        // Broadcast update
        world.broadcast(Message::PriceUpdate {
            asset: "ETH".to_string(),
            price: new_price,
        }).await?;
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="network-effects"><a class="header" href="#network-effects">Network Effects</a></h2>
<p>Model interactions between agents:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NetworkSimulation {
    agents: Vec&lt;Agent&gt;,
    network: Graph&lt;AgentId, Relationship&gt;,
}

impl NetworkSimulation {
    async fn propagate_influence(&amp;mut self, source: AgentId) -&gt; Result&lt;()&gt; {
        // Find neighbors
        let neighbors = self.network.neighbors(source);
        
        // Influence spreads through network
        for neighbor in neighbors {
            if let Some(agent) = self.agents.get_mut(&amp;neighbor) {
                agent.receive_influence(source).await?;
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-20"><a class="header" href="#next-steps-20">Next Steps</a></h2>
<ul>
<li><a href="advanced/./anomaly_detection.html">Anomaly Detection</a> - Detecting unusual behavior</li>
<li><a href="advanced/./testing_strategies.html">Testing Strategies</a> - Testing approaches</li>
<li><a href="advanced/./performance.html">Performance Optimization</a> - Optimizing simulations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="anomaly-detection"><a class="header" href="#anomaly-detection">Anomaly Detection</a></h1>
<p>Use Starkbiter to detect anomalies and vulnerabilities in smart contract systems through simulation-based analysis.</p>
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p>Anomaly detection in Starkbiter involves:</p>
<ul>
<li>Defining normal system behavior</li>
<li>Running simulations with various conditions</li>
<li>Identifying deviations from expected behavior</li>
<li>Analyzing root causes of anomalies</li>
</ul>
<h2 id="statistical-anomaly-detection"><a class="header" href="#statistical-anomaly-detection">Statistical Anomaly Detection</a></h2>
<h3 id="baseline-behavior"><a class="header" href="#baseline-behavior">Baseline Behavior</a></h3>
<p>Establish normal behavior patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BehaviorBaseline {
    mean_gas_usage: f64,
    std_gas_usage: f64,
    mean_execution_time: f64,
    typical_event_counts: HashMap&lt;String, f64&gt;,
}

impl BehaviorBaseline {
    async fn establish(env: &amp;Environment, runs: usize) -&gt; Result&lt;Self&gt; {
        let mut gas_samples = vec![];
        let mut time_samples = vec![];
        
        for _ in 0..runs {
            let start = Instant::now();
            let result = run_normal_simulation(env).await?;
            
            gas_samples.push(result.gas_used as f64);
            time_samples.push(start.elapsed().as_secs_f64());
        }
        
        Ok(Self {
            mean_gas_usage: mean(&amp;gas_samples),
            std_gas_usage: std_dev(&amp;gas_samples),
            mean_execution_time: mean(&amp;time_samples),
            typical_event_counts: result.event_counts,
        })
    }
    
    fn is_anomalous(&amp;self, observation: &amp;Observation) -&gt; bool {
        let z_score = (observation.gas_used as f64 - self.mean_gas_usage)
            / self.std_gas_usage;
        
        z_score.abs() &gt; 3.0  // 3-sigma rule
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="detecting-outliers"><a class="header" href="#detecting-outliers">Detecting Outliers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn detect_gas_anomalies(
    protocol: &amp;Protocol,
    operations: Vec&lt;Operation&gt;,
) -&gt; Result&lt;Vec&lt;Anomaly&gt;&gt; {
    let baseline = BehaviorBaseline::establish(&amp;protocol.env, 100).await?;
    let mut anomalies = vec![];
    
    for op in operations {
        let result = protocol.execute(op).await?;
        
        if baseline.is_anomalous(&amp;result) {
            anomalies.push(Anomaly {
                operation: op,
                gas_used: result.gas_used,
                expected_gas: baseline.mean_gas_usage,
                deviation: (result.gas_used as f64 - baseline.mean_gas_usage)
                    / baseline.mean_gas_usage,
            });
        }
    }
    
    Ok(anomalies)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="invariant-violation-detection"><a class="header" href="#invariant-violation-detection">Invariant Violation Detection</a></h2>
<h3 id="define-invariants"><a class="header" href="#define-invariants">Define Invariants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ProtocolInvariants {
    rules: Vec&lt;Box&lt;dyn Invariant&gt;&gt;,
}

trait Invariant {
    async fn check(&amp;self, world: &amp;World) -&gt; Result&lt;bool&gt;;
    fn description(&amp;self) -&gt; &amp;str;
}

// Example: Total supply invariant
struct TotalSupplyInvariant {
    token_address: Felt,
    expected_supply: Felt,
}

impl Invariant for TotalSupplyInvariant {
    async fn check(&amp;self, world: &amp;World) -&gt; Result&lt;bool&gt; {
        let token = ERC20::new(self.token_address, &amp;world.account());
        let actual = token.total_supply().await?;
        Ok(actual == self.expected_supply)
    }
    
    fn description(&amp;self) -&gt; &amp;str {
        "Total token supply must remain constant"
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="monitor-invariants"><a class="header" href="#monitor-invariants">Monitor Invariants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn monitor_invariants(
    world: &amp;World,
    invariants: &amp;ProtocolInvariants,
) -&gt; Result&lt;Vec&lt;Violation&gt;&gt; {
    let mut violations = vec![];
    
    for invariant in &amp;invariants.rules {
        if !invariant.check(world).await? {
            violations.push(Violation {
                rule: invariant.description().to_string(),
                timestamp: world.get_timestamp().await?,
                block: world.get_block_number().await?,
            });
        }
    }
    
    Ok(violations)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="behavioral-analysis"><a class="header" href="#behavioral-analysis">Behavioral Analysis</a></h2>
<h3 id="track-agent-behavior"><a class="header" href="#track-agent-behavior">Track Agent Behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BehaviorMonitor {
    agent_patterns: HashMap&lt;String, BehaviorPattern&gt;,
}

impl BehaviorMonitor {
    fn record_action(&amp;mut self, agent_id: &amp;str, action: Action) {
        let pattern = self.agent_patterns
            .entry(agent_id.to_string())
            .or_insert(BehaviorPattern::new());
        
        pattern.add_action(action);
    }
    
    fn detect_suspicious_behavior(&amp;self) -&gt; Vec&lt;Alert&gt; {
        let mut alerts = vec![];
        
        for (agent_id, pattern) in &amp;self.agent_patterns {
            // Detect unusual frequency
            if pattern.action_rate() &gt; pattern.typical_rate() * 10.0 {
                alerts.push(Alert::UnusualFrequency {
                    agent: agent_id.clone(),
                    rate: pattern.action_rate(),
                });
            }
            
            // Detect unusual amounts
            if pattern.max_amount() &gt; pattern.typical_amount() * 100.0 {
                alerts.push(Alert::UnusualAmount {
                    agent: agent_id.clone(),
                    amount: pattern.max_amount(),
                });
            }
        }
        
        alerts
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="flash-loan-attack-detection"><a class="header" href="#flash-loan-attack-detection">Flash Loan Attack Detection</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct FlashLoanDetector {
    threshold_borrow: u64,
    threshold_profit: u64,
}

impl FlashLoanDetector {
    async fn monitor_block(&amp;self, world: &amp;World) -&gt; Result&lt;Vec&lt;AttackAlert&gt;&gt; {
        let mut alerts = vec![];
        let events = world.get_recent_events().await?;
        
        // Group events by transaction
        let tx_groups = self.group_by_transaction(events);
        
        for (tx_hash, tx_events) in tx_groups {
            // Look for borrow-repay in same transaction
            let borrowed = self.find_borrows(&amp;tx_events);
            let repaid = self.find_repayments(&amp;tx_events);
            
            if !borrowed.is_empty() &amp;&amp; !repaid.is_empty() {
                let total_borrowed: u64 = borrowed.iter().map(|b| b.amount).sum();
                let profit = self.calculate_profit(&amp;tx_events);
                
                if total_borrowed &gt; self.threshold_borrow
                    &amp;&amp; profit &gt; self.threshold_profit {
                    alerts.push(AttackAlert::FlashLoan {
                        tx: tx_hash,
                        borrowed: total_borrowed,
                        profit,
                    });
                }
            }
        }
        
        Ok(alerts)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="price-manipulation-detection"><a class="header" href="#price-manipulation-detection">Price Manipulation Detection</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PriceManipulationDetector {
    price_impact_threshold: f64,
}

impl PriceManipulationDetector {
    async fn detect(&amp;self, pool: &amp;Pool) -&gt; Result&lt;Option&lt;ManipulationAlert&gt;&gt; {
        let snapshot = pool.snapshot().await?;
        
        // Simulate large trade
        let large_trade = pool.max_trade_size() * 0.5;
        let price_before = pool.get_price().await?;
        
        pool.simulate_swap(large_trade).await?;
        let price_after = pool.get_price().await?;
        
        let price_impact = (price_after - price_before) / price_before;
        
        // Restore state
        pool.restore(snapshot).await?;
        
        if price_impact.abs() &gt; self.price_impact_threshold {
            Ok(Some(ManipulationAlert {
                pool: pool.address(),
                price_impact,
                vulnerable_to_manipulation: true,
            }))
        } else {
            Ok(None)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="machine-learning-based-detection"><a class="header" href="#machine-learning-based-detection">Machine Learning-Based Detection</a></h2>
<h3 id="feature-extraction"><a class="header" href="#feature-extraction">Feature Extraction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TransactionFeatures {
    gas_used: f64,
    value_transferred: f64,
    num_calls: f64,
    unique_contracts: f64,
    loops_detected: bool,
    reentrancy_risk: f64,
}

impl TransactionFeatures {
    async fn extract(tx: &amp;Transaction, world: &amp;World) -&gt; Result&lt;Self&gt; {
        // Analyze transaction
        let trace = world.trace_transaction(tx).await?;
        
        Ok(Self {
            gas_used: trace.gas_used as f64,
            value_transferred: trace.value_transferred as f64,
            num_calls: trace.calls.len() as f64,
            unique_contracts: trace.unique_contracts().len() as f64,
            loops_detected: trace.has_loops(),
            reentrancy_risk: trace.calculate_reentrancy_risk(),
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="anomaly-scoring"><a class="header" href="#anomaly-scoring">Anomaly Scoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AnomalyDetector {
    model: Box&lt;dyn AnomalyModel&gt;,
}

impl AnomalyDetector {
    fn score(&amp;self, features: &amp;TransactionFeatures) -&gt; f64 {
        self.model.predict_anomaly_score(features)
    }
    
    fn classify(&amp;self, features: &amp;TransactionFeatures) -&gt; Classification {
        let score = self.score(features);
        
        if score &gt; 0.9 {
            Classification::HighRisk
        } else if score &gt; 0.7 {
            Classification::MediumRisk
        } else {
            Classification::Normal
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="reporting"><a class="header" href="#reporting">Reporting</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AnomalyReport {
    anomalies: Vec&lt;Anomaly&gt;,
    severity_distribution: HashMap&lt;Severity, usize&gt;,
    recommendations: Vec&lt;String&gt;,
}

impl AnomalyReport {
    fn generate(detections: Vec&lt;Detection&gt;) -&gt; Self {
        let mut anomalies = vec![];
        let mut severity_dist = HashMap::new();
        
        for detection in detections {
            let anomaly = Anomaly::from(detection);
            *severity_dist.entry(anomaly.severity).or_insert(0) += 1;
            anomalies.push(anomaly);
        }
        
        let recommendations = Self::generate_recommendations(&amp;anomalies);
        
        Self {
            anomalies,
            severity_distribution: severity_dist,
            recommendations,
        }
    }
    
    fn to_markdown(&amp;self) -&gt; String {
        // Generate markdown report
        format!(
            "# Anomaly Detection Report\n\n\
             # Summary\n\
             - Total anomalies: {}\n\
             - Critical: {}\n\
             - High: {}\n\
             - Medium: {}\n\
             - Low: {}\n\n\
             # Recommendations\n{}\n",
            self.anomalies.len(),
            self.severity_distribution.get(&amp;Severity::Critical).unwrap_or(&amp;0),
            self.severity_distribution.get(&amp;Severity::High).unwrap_or(&amp;0),
            self.severity_distribution.get(&amp;Severity::Medium).unwrap_or(&amp;0),
            self.severity_distribution.get(&amp;Severity::Low).unwrap_or(&amp;0),
            self.recommendations.join("\n"),
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-21"><a class="header" href="#next-steps-21">Next Steps</a></h2>
<ul>
<li><a href="advanced/./testing_strategies.html">Testing Strategies</a> - Testing approaches</li>
<li><a href="advanced/./simulation_techniques.html">Simulation Techniques</a> - Simulation patterns</li>
<li><a href="advanced/./performance.html">Performance Optimization</a> - Optimizing detection</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h1>
<p>Techniques for optimizing the performance of your Starkbiter simulations and tests.</p>
<h2 id="general-optimization"><a class="header" href="#general-optimization">General Optimization</a></h2>
<h3 id="parallel-execution"><a class="header" href="#parallel-execution">Parallel Execution</a></h3>
<p>Run independent tests in parallel:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn parallel_tests() {
    // Tests run concurrently
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations-2"><a class="header" href="#batch-operations-2">Batch Operations</a></h3>
<p>Group operations to reduce overhead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::try_join;

// Instead of sequential
let balance1 = env.get_balance(addr1).await?;
let balance2 = env.get_balance(addr2).await?;
let balance3 = env.get_balance(addr3).await?;

// Use concurrent
let (balance1, balance2, balance3) = try_join!(
    env.get_balance(addr1),
    env.get_balance(addr2),
    env.get_balance(addr3),
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="reuse-environments"><a class="header" href="#reuse-environments">Reuse Environments</a></h3>
<p>Reuse environments when possible:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Expensive: create new environment for each test
#[tokio::test]
async fn test1() {
    let env = Environment::builder().build().await?;
    // ...
}

// Better: use fixtures with snapshots
async fn test_fixture() -&gt; (Environment, SnapshotId) {
    let env = Environment::builder().build().await?;
    // Setup common state
    let snapshot = env.snapshot().await?;
    (env, snapshot)
}

#[tokio::test]
async fn test1() {
    let (env, snapshot) = test_fixture().await;
    // ... test ...
    env.restore(snapshot).await?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="environment-optimization"><a class="header" href="#environment-optimization">Environment Optimization</a></h2>
<h3 id="disable-unnecessary-features"><a class="header" href="#disable-unnecessary-features">Disable Unnecessary Features</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let env = Environment::builder()
    .with_minimal_setup()  // Skip unnecessary initialization
    .build()
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="control-block-production"><a class="header" href="#control-block-production">Control Block Production</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manual block production for testing
let env = Environment::builder()
    .with_block_time(0)  // Manual mode
    .build()
    .await?;

// Only mine when needed
env.mine_block().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="agent-optimization"><a class="header" href="#agent-optimization">Agent Optimization</a></h2>
<h3 id="efficient-state-management"><a class="header" href="#efficient-state-management">Efficient State Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad: Deep cloning on every execution
struct InefficientBehavior {
    large_state: Vec&lt;LargeData&gt;, // Cloned frequently
}

// Good: Use references and Arc
struct EfficientBehavior {
    large_state: Arc&lt;Vec&lt;LargeData&gt;&gt;, // Shared reference
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LazyBehavior {
    cached_data: Option&lt;ExpensiveData&gt;,
}

impl Behavior for LazyBehavior {
    async fn execute(&amp;mut self, world: &amp;World) -&gt; Result&lt;()&gt; {
        // Only compute when needed
        let data = match &amp;self.cached_data {
            Some(d) =&gt; d,
            None =&gt; {
                let d = self.compute_expensive_data(world).await?;
                self.cached_data = Some(d);
                self.cached_data.as_ref().unwrap()
            }
        };
        
        self.use_data(data).await?;
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<h3 id="resource-cleanup"><a class="header" href="#resource-cleanup">Resource Cleanup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for MyAgent {
    fn drop(&amp;mut self) {
        // Clean up resources
        self.close_connections();
        self.flush_caches();
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="limit-cache-sizes"><a class="header" href="#limit-cache-sizes">Limit Cache Sizes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use lru::LruCache;

struct CachedBehavior {
    cache: LruCache&lt;Key, Value&gt;,
}

impl CachedBehavior {
    fn new() -&gt; Self {
        Self {
            cache: LruCache::new(1000.try_into().unwrap()), // Limit cache size
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<h3 id="measure-performance"><a class="header" href="#measure-performance">Measure Performance</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

async fn measure_performance&lt;F, T&gt;(name: &amp;str, f: F) -&gt; T
where
    F: Future&lt;Output = T&gt;,
{
    let start = Instant::now();
    let result = f.await;
    let elapsed = start.elapsed();
    println!("{} took {:?}", name, elapsed);
    result
}

// Usage
let result = measure_performance("deploy_contract", async {
    deploy_contract(&amp;account).await
}).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="profile-with-tokio-console"><a class="header" href="#profile-with-tokio-console">Profile with tokio-console</a></h3>
<pre><pre class="playground"><code class="language-rust">// Add to Cargo.toml
// [dependencies]
// console-subscriber = "0.1"

// In main
#[tokio::main]
async fn main() {
    console_subscriber::init();
    // ... your code
}</code></pre></pre>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<p>Use Criterion for benchmarking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_contract_call(c: &amp;mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    c.bench_function("contract_call", |b| {
        b.to_async(&amp;rt).iter(|| async {
            let env = Environment::builder().build().await.unwrap();
            let account = env.create_account().await.unwrap();
            let contract = deploy_contract(&amp;account).await.unwrap();
            
            black_box(contract.call_method().await.unwrap())
        });
    });
}

criterion_group!(benches, bench_contract_call);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-22"><a class="header" href="#next-steps-22">Next Steps</a></h2>
<ul>
<li><a href="advanced/./testing_strategies.html">Testing Strategies</a> - Effective testing</li>
<li><a href="advanced/./simulation_techniques.html">Simulation Techniques</a> - Advanced simulations</li>
<li><a href="advanced/./anomaly_detection.html">Anomaly Detection</a> - Detecting issues</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="contributing-to-starkbiter"><a class="header" href="#contributing-to-starkbiter">Contributing to Starkbiter</a></h1>
<p>Thank you for your interest in contributing to Starkbiter! This guide will help you get started.</p>
<h2 id="ways-to-contribute"><a class="header" href="#ways-to-contribute">Ways to Contribute</a></h2>
<p>There are many ways to contribute to Starkbiter:</p>
<ul>
<li>ğŸ› <strong>Report bugs</strong> - Found an issue? Let us know!</li>
<li>ğŸ’¡ <strong>Suggest features</strong> - Have an idea? We'd love to hear it!</li>
<li>ğŸ“– <strong>Improve documentation</strong> - Help make our docs better</li>
<li>ğŸ§ª <strong>Add examples</strong> - Share your simulations with the community</li>
<li>ğŸ”§ <strong>Fix issues</strong> - Submit pull requests for open issues</li>
<li>â­ <strong>Spread the word</strong> - Tell others about Starkbiter</li>
</ul>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<h3 id="1-fork-the-repository"><a class="header" href="#1-fork-the-repository">1. Fork the Repository</a></h3>
<p>Fork <a href="https://github.com/astraly-labs/starkbiter">starkbiter</a> on GitHub.</p>
<h3 id="2-clone-your-fork"><a class="header" href="#2-clone-your-fork">2. Clone Your Fork</a></h3>
<pre><code class="language-bash">git clone https://github.com/YOUR_USERNAME/starkbiter
cd starkbiter
</code></pre>
<h3 id="3-set-up-development-environment"><a class="header" href="#3-set-up-development-environment">3. Set Up Development Environment</a></h3>
<pre><code class="language-bash"># Install Rust (if not already installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build the project
cargo build

# Run tests
cargo test --all --all-features
</code></pre>
<h3 id="4-create-a-branch"><a class="header" href="#4-create-a-branch">4. Create a Branch</a></h3>
<pre><code class="language-bash">git checkout -b feature/your-feature-name
</code></pre>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="making-changes"><a class="header" href="#making-changes">Making Changes</a></h3>
<ol>
<li><strong>Write code</strong> - Implement your feature or fix</li>
<li><strong>Add tests</strong> - Ensure your code is tested</li>
<li><strong>Update docs</strong> - Document new features</li>
<li><strong>Run tests</strong> - Make sure everything works</li>
<li><strong>Commit changes</strong> - Use clear commit messages</li>
</ol>
<h3 id="commit-messages"><a class="header" href="#commit-messages">Commit Messages</a></h3>
<p>Follow conventional commits:</p>
<pre><code>feat: add support for custom gas prices
fix: resolve race condition in agent execution
docs: improve quickstart guide
test: add integration tests for forking
refactor: simplify environment builder
</code></pre>
<h3 id="testing-1"><a class="header" href="#testing-1">Testing</a></h3>
<p>Run the full test suite:</p>
<pre><code class="language-bash"># All tests
cargo test --all --all-features

# Specific package
cargo test -p starkbiter-core

# With output
cargo test -- --nocapture
</code></pre>
<h3 id="code-style"><a class="header" href="#code-style">Code Style</a></h3>
<p>We use rustfmt and clippy:</p>
<pre><code class="language-bash"># Format code
cargo fmt --all

# Check for issues
cargo clippy --all --all-features
</code></pre>
<h2 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h2>
<h3 id="before-submitting"><a class="header" href="#before-submitting">Before Submitting</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Tests pass locally</li>
<li><input disabled="" type="checkbox"/>
Code is formatted (<code>cargo fmt</code>)</li>
<li><input disabled="" type="checkbox"/>
No clippy warnings (<code>cargo clippy</code>)</li>
<li><input disabled="" type="checkbox"/>
Documentation is updated</li>
<li><input disabled="" type="checkbox"/>
Examples work</li>
<li><input disabled="" type="checkbox"/>
Changelog updated (if applicable)</li>
</ul>
<h3 id="submitting"><a class="header" href="#submitting">Submitting</a></h3>
<ol>
<li>
<p><strong>Push to your fork</strong></p>
<pre><code class="language-bash">git push origin feature/your-feature-name
</code></pre>
</li>
<li>
<p><strong>Create Pull Request</strong> on GitHub</p>
</li>
<li>
<p><strong>Fill out the template</strong></p>
<ul>
<li>Describe your changes</li>
<li>Link related issues</li>
<li>Add screenshots if applicable</li>
</ul>
</li>
<li>
<p><strong>Wait for review</strong></p>
<ul>
<li>Address feedback</li>
<li>Make requested changes</li>
<li>Keep discussion constructive</li>
</ul>
</li>
</ol>
<h3 id="review-process"><a class="header" href="#review-process">Review Process</a></h3>
<ul>
<li>Maintainers will review your PR</li>
<li>CI must pass (tests, formatting, clippy)</li>
<li>At least one approval required</li>
<li>Maintainer will merge when ready</li>
</ul>
<h2 id="code-guidelines"><a class="header" href="#code-guidelines">Code Guidelines</a></h2>
<h3 id="rust-style"><a class="header" href="#rust-style">Rust Style</a></h3>
<ul>
<li>Follow <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a></li>
<li>Use <code>rustfmt</code> defaults</li>
<li>Prefer explicit types in public APIs</li>
<li>Document public items</li>
</ul>
<h3 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Use Result and descriptive errors
async fn deploy_contract(&amp;self) -&gt; Result&lt;ContractAddress&gt; {
    self.declare().await?;
    self.deploy().await
        .context("Failed to deploy contract")
}

// Avoid: Unwrap or panic in library code
async fn bad_deploy(&amp;self) -&gt; ContractAddress {
    self.deploy().await.unwrap()  // Don't do this!
}
<span class="boring">}</span></code></pre></pre>
<h3 id="documentation-2"><a class="header" href="#documentation-2">Documentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Deploys a new contract instance.
///
/// # Arguments
///
/// * `account` - The account to deploy from
/// * `class_hash` - The declared contract class hash
/// * `constructor_calldata` - Arguments for the constructor
///
/// # Returns
///
/// The address of the deployed contract
///
/// # Errors
///
/// Returns an error if deployment fails or if the class is not declared
///
/// # Example
///
/// ```rust
/// let address = env.deploy_contract(
///     &amp;account,
///     class_hash,
///     vec![],
/// ).await?;
/// ```
pub async fn deploy_contract(
    &amp;self,
    account: &amp;Account,
    class_hash: Felt,
    constructor_calldata: Vec&lt;Felt&gt;,
) -&gt; Result&lt;Felt&gt; {
    // Implementation
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-2"><a class="header" href="#testing-2">Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Unit tests in same file
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_feature() {
        // Test code
    }
}

// Integration tests in tests/
// tests/integration_test.rs
<span class="boring">}</span></code></pre></pre>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<pre><code>starkbiter/
â”œâ”€â”€ bin/              # CLI binary
â”œâ”€â”€ bindings/         # Contract bindings
â”œâ”€â”€ core/             # Core library
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ environment/
â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ tokens/
â”‚   â””â”€â”€ tests/
â”œâ”€â”€ engine/           # Engine library
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ agent.rs
â”‚   â”‚   â”œâ”€â”€ behavior.rs
â”‚   â”‚   â””â”€â”€ world.rs
â”‚   â””â”€â”€ tests/
â”œâ”€â”€ macros/           # Procedural macros
â”œâ”€â”€ examples/         # Example simulations
â””â”€â”€ docs/             # Documentation (mdBook)
</code></pre>
<h2 id="documentation-3"><a class="header" href="#documentation-3">Documentation</a></h2>
<h3 id="building-the-book"><a class="header" href="#building-the-book">Building the Book</a></h3>
<pre><code class="language-bash"># Install mdbook
cargo install mdbook mdbook-katex

# Build and serve
cd docs
mdbook serve

# Open http://localhost:3000
</code></pre>
<h3 id="adding-documentation"><a class="header" href="#adding-documentation">Adding Documentation</a></h3>
<ul>
<li>Update SUMMARY.md for new pages</li>
<li>Use markdown for content</li>
<li>Add code examples</li>
<li>Keep it beginner-friendly</li>
</ul>
<h2 id="examples-4"><a class="header" href="#examples-4">Examples</a></h2>
<p>When adding examples:</p>
<ol>
<li>Create directory under <code>examples/</code></li>
<li>Add <code>main.rs</code> and supporting files</li>
<li>Document in <code>examples/README.md</code></li>
<li>Update book's examples page</li>
</ol>
<h2 id="community-2"><a class="header" href="#community-2">Community</a></h2>
<h3 id="communication-channels"><a class="header" href="#communication-channels">Communication Channels</a></h3>
<ul>
<li><strong>GitHub Discussions</strong> - Ask questions, share ideas</li>
<li><strong>GitHub Issues</strong> - Report bugs, request features</li>
<li><strong>Pull Requests</strong> - Submit code changes</li>
</ul>
<h3 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h3>
<p>Be respectful and constructive. We're all here to learn and build together.</p>
<h2 id="getting-help-3"><a class="header" href="#getting-help-3">Getting Help</a></h2>
<ul>
<li>Read the <a href="https://astraly-labs.github.io/starkbiter/">documentation</a></li>
<li>Search <a href="https://github.com/astraly-labs/starkbiter/issues">existing issues</a></li>
<li>Ask in <a href="https://github.com/astraly-labs/starkbiter/discussions">discussions</a></li>
<li>Check the <a href="https://github.com/astraly-labs/starkbiter/tree/main/examples">examples</a></li>
</ul>
<h2 id="recognition"><a class="header" href="#recognition">Recognition</a></h2>
<p>Contributors are recognized in:</p>
<ul>
<li><code>CONTRIBUTORS.md</code></li>
<li>Release notes</li>
<li>Documentation credits</li>
</ul>
<p>Thank you for contributing to Starkbiter! ğŸš€</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<p>Detailed guide for setting up your Starkbiter development environment.</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Install Rust using rustup:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup update
</code></pre>
<h3 id="additional-tools"><a class="header" href="#additional-tools">Additional Tools</a></h3>
<pre><code class="language-bash"># Code formatting
rustup component add rustfmt

# Linting
rustup component add clippy

# Documentation
cargo install mdbook mdbook-katex

# Development tools
cargo install cargo-watch  # Auto-rebuild on changes
cargo install cargo-expand # Expand macros
</code></pre>
<h2 id="building-the-project"><a class="header" href="#building-the-project">Building the Project</a></h2>
<h3 id="full-build"><a class="header" href="#full-build">Full Build</a></h3>
<pre><code class="language-bash"># Clone repository
git clone https://github.com/astraly-labs/starkbiter
cd starkbiter

# Build all crates
cargo build --all --all-features

# Build in release mode
cargo build --release --all --all-features
</code></pre>
<h3 id="individual-crates"><a class="header" href="#individual-crates">Individual Crates</a></h3>
<pre><code class="language-bash"># Build specific crate
cargo build -p starkbiter-core
cargo build -p starkbiter-engine
cargo build -p starkbiter-bindings

# With features
cargo build -p starkbiter-core --features "cheating"
</code></pre>
<h2 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h2>
<h3 id="all-tests"><a class="header" href="#all-tests">All Tests</a></h3>
<pre><code class="language-bash"># Run all tests
cargo test --all --all-features

# With output
cargo test --all --all-features -- --nocapture

# Specific test
cargo test test_name --all-features
</code></pre>
<h3 id="package-specific-tests"><a class="header" href="#package-specific-tests">Package-Specific Tests</a></h3>
<pre><code class="language-bash"># Core tests
cargo test -p starkbiter-core

# Engine tests
cargo test -p starkbiter-engine

# Integration tests only
cargo test --test '*'
</code></pre>
<h3 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h3>
<pre><code class="language-bash"># Install tarpaulin
cargo install cargo-tarpaulin

# Generate coverage report
cargo tarpaulin --all --all-features --out Html
</code></pre>
<h2 id="code-quality"><a class="header" href="#code-quality">Code Quality</a></h2>
<h3 id="formatting"><a class="header" href="#formatting">Formatting</a></h3>
<pre><code class="language-bash"># Check formatting
cargo fmt --all -- --check

# Format code
cargo fmt --all
</code></pre>
<h3 id="linting"><a class="header" href="#linting">Linting</a></h3>
<pre><code class="language-bash"># Check for issues
cargo clippy --all --all-features

# Fix automatically where possible
cargo clippy --all --all-features --fix
</code></pre>
<h3 id="documentation-4"><a class="header" href="#documentation-4">Documentation</a></h3>
<pre><code class="language-bash"># Build docs
cargo doc --all --all-features --no-deps

# Open in browser
cargo doc --all --all-features --no-deps --open

# Check for broken links
cargo doc --all --all-features --no-deps 2&gt;&amp;1 | grep warning
</code></pre>
<h2 id="development-workflow-1"><a class="header" href="#development-workflow-1">Development Workflow</a></h2>
<h3 id="watch-mode"><a class="header" href="#watch-mode">Watch Mode</a></h3>
<p>Auto-rebuild on file changes:</p>
<pre><code class="language-bash"># Watch and rebuild
cargo watch -x build

# Watch and test
cargo watch -x test

# Watch and run example
cargo watch -x "run --example minter"
</code></pre>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add debug prints
println!("Debug: {:?}", value);
dbg!(value);

// Or use the log crate
use log::{debug, info, error};

debug!("Detailed information");
info!("General information");
error!("Error occurred: {}", e);
<span class="boring">}</span></code></pre></pre>
<p>Run with logging:</p>
<pre><code class="language-bash">RUST_LOG=debug cargo test
RUST_LOG=starkbiter_core=trace cargo run --example minter
</code></pre>
<h3 id="benchmarking-1"><a class="header" href="#benchmarking-1">Benchmarking</a></h3>
<pre><code class="language-bash"># Run benchmarks
cargo bench -p starkbiter-core

# Compare benchmarks
cargo bench --bench bench_name -- --save-baseline before
# ... make changes ...
cargo bench --bench bench_name -- --baseline before
</code></pre>
<h2 id="working-with-examples"><a class="header" href="#working-with-examples">Working with Examples</a></h2>
<h3 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h3>
<pre><code class="language-bash"># List examples
cargo run --example --list

# Run example
cargo run --example minter

# With arguments
cargo run --example minter simulate ./examples/minter/config.toml -vvvv
</code></pre>
<h3 id="creating-examples"><a class="header" href="#creating-examples">Creating Examples</a></h3>
<pre><code class="language-bash"># Create new example
mkdir examples/my_example
touch examples/my_example/main.rs

# Add to workspace if needed
# (usually automatic)
</code></pre>
<h2 id="documentation-development"><a class="header" href="#documentation-development">Documentation Development</a></h2>
<h3 id="building-the-book-1"><a class="header" href="#building-the-book-1">Building the Book</a></h3>
<pre><code class="language-bash">cd docs

# Install dependencies
cargo install mdbook mdbook-katex

# Build
mdbook build

# Serve with auto-reload
mdbook serve

# Open http://localhost:3000
</code></pre>
<h3 id="adding-pages"><a class="header" href="#adding-pages">Adding Pages</a></h3>
<ol>
<li>Create markdown file in <code>docs/src/</code></li>
<li>Update <code>docs/src/SUMMARY.md</code></li>
<li>Test locally with <code>mdbook serve</code></li>
</ol>
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE Setup</a></h2>
<h3 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h3>
<p>Recommended extensions:</p>
<ul>
<li>rust-analyzer</li>
<li>CodeLLDB (debugging)</li>
<li>Even Better TOML</li>
<li>Error Lens</li>
</ul>
<p><code>settings.json</code>:</p>
<pre><code class="language-json">{
    "rust-analyzer.checkOnSave.command": "clippy",
    "rust-analyzer.cargo.features": "all",
    "[rust]": {
        "editor.defaultFormatter": "rust-lang.rust-analyzer",
        "editor.formatOnSave": true
    }
}
</code></pre>
<h3 id="intellij-idea--clion"><a class="header" href="#intellij-idea--clion">IntelliJ IDEA / CLion</a></h3>
<ul>
<li>Install Rust plugin</li>
<li>Enable rustfmt on save</li>
<li>Configure clippy as external tool</li>
</ul>
<h2 id="troubleshooting-5"><a class="header" href="#troubleshooting-5">Troubleshooting</a></h2>
<h3 id="build-issues"><a class="header" href="#build-issues">Build Issues</a></h3>
<pre><code class="language-bash"># Clean build artifacts
cargo clean

# Update dependencies
cargo update

# Check dependency tree
cargo tree
</code></pre>
<h3 id="test-failures"><a class="header" href="#test-failures">Test Failures</a></h3>
<pre><code class="language-bash"># Run specific test with output
cargo test test_name -- --nocapture

# Run ignored tests
cargo test -- --ignored

# Run in single-threaded mode
cargo test -- --test-threads=1
</code></pre>
<h3 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h3>
<pre><code class="language-bash"># Profile with flamegraph
cargo install flamegraph
cargo flamegraph --example minter

# Use release mode
cargo build --release
cargo test --release
</code></pre>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<p>Our CI runs:</p>
<ul>
<li>Tests on Linux, macOS, Windows</li>
<li>Formatting checks</li>
<li>Clippy lints</li>
<li>Documentation builds</li>
<li>Example builds</li>
</ul>
<p>Make sure your PR passes all checks:</p>
<pre><code class="language-bash"># Run CI checks locally
cargo fmt --all -- --check
cargo clippy --all --all-features -- -D warnings
cargo test --all --all-features
cargo build --examples
</code></pre>
<h2 id="next-steps-23"><a class="header" href="#next-steps-23">Next Steps</a></h2>
<ul>
<li><a href="contributing/./index.html">Contributing Guidelines</a> - How to contribute</li>
<li><a href="contributing/./code_style.html">Code Style Guide</a> - Coding standards</li>
<li><a href="contributing/./testing.html">Testing Guide</a> - Writing tests</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<h1 id="vulnerability-corpus"><a class="header" href="#vulnerability-corpus">Vulnerability Corpus</a></h1>
<p>A collection of known vulnerabilities and security issues that Starkbiter can help detect and prevent.</p>
<h2 id="overview-13"><a class="header" href="#overview-13">Overview</a></h2>
<p>This corpus catalogs common vulnerabilities in smart contracts, particularly in the Starknet/Cairo ecosystem, and demonstrates how Starkbiter can be used to detect them through simulation and testing.</p>
<h2 id="vulnerability-categories"><a class="header" href="#vulnerability-categories">Vulnerability Categories</a></h2>
<h3 id="1-reentrancy"><a class="header" href="#1-reentrancy">1. Reentrancy</a></h3>
<p><strong>Description:</strong> Attackers exploit function calls that allow external contract calls before state updates.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_reentrancy_vulnerability() {
    let env = Environment::builder().build().await?;
    let (victim, attacker) = setup_reentrancy_test(&amp;env).await?;
    
    // Attempt reentrancy attack
    let initial_balance = victim.get_balance().await?;
    attacker.exploit().await?;
    let final_balance = victim.get_balance().await?;
    
    // Should not allow draining
    assert_eq!(initial_balance, final_balance);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Use checks-effects-interactions pattern, reentrancy guards.</p>
<h3 id="2-integer-overflowunderflow"><a class="header" href="#2-integer-overflowunderflow">2. Integer Overflow/Underflow</a></h3>
<p><strong>Description:</strong> Arithmetic operations that exceed type bounds.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_overflow_vulnerability() {
    let env = Environment::builder().build().await?;
    let contract = deploy_vulnerable_contract(&amp;env).await?;
    
    // Try to overflow
    let max_value = Felt::from(u128::MAX);
    let result = contract.add(max_value, Felt::ONE).await;
    
    // Should handle overflow safely
    assert!(result.is_err() || result.unwrap() != Felt::ZERO);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Use checked arithmetic, Felt type bounds checking.</p>
<h3 id="3-access-control-issues"><a class="header" href="#3-access-control-issues">3. Access Control Issues</a></h3>
<p><strong>Description:</strong> Missing or incorrect permission checks.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_access_control() {
    let env = Environment::builder().build().await?;
    let owner = env.create_account().await?;
    let attacker = env.create_account().await?;
    
    let contract = deploy_with_owner(&amp;env, &amp;owner).await?;
    
    // Attacker tries privileged operation
    let result = contract.as_account(&amp;attacker).privileged_function().await;
    
    // Should be rejected
    assert!(result.is_err());
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Implement proper role-based access control.</p>
<h3 id="4-front-running"><a class="header" href="#4-front-running">4. Front-Running</a></h3>
<p><strong>Description:</strong> Attackers observe pending transactions and submit competing transactions with higher fees.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_frontrunning_vulnerability() {
    let env = Environment::builder().build().await?;
    let world = World::new(env);
    
    // Add frontrunner agent
    world.add_agent(Agent::new("frontrunner", FrontRunnerBehavior));
    world.add_agent(Agent::new("victim", VictimBehavior));
    
    world.run_for_blocks(100).await?;
    
    // Analyze if frontrunning occurred
    let metrics = world.get_metrics();
    assert!(metrics.frontrunning_detected == false, "Vulnerable to frontrunning");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Use commit-reveal schemes, batch auctions.</p>
<h3 id="5-price-oracle-manipulation"><a class="header" href="#5-price-oracle-manipulation">5. Price Oracle Manipulation</a></h3>
<p><strong>Description:</strong> Attackers manipulate price oracles to exploit DeFi protocols.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_oracle_manipulation() {
    let env = Environment::builder().build().await?;
    let protocol = deploy_lending_protocol(&amp;env).await?;
    let pool = deploy_dex_pool(&amp;env).await?;
    
    // Take snapshot
    let snapshot = env.snapshot().await?;
    
    // Simulate large trade to manipulate price
    let whale = create_whale_account(&amp;env).await?;
    pool.swap(&amp;whale, large_amount).await?;
    
    // Try to exploit with manipulated price
    let profit = protocol.exploit_price_manipulation(&amp;env).await?;
    
    // Restore
    env.restore(snapshot).await?;
    
    // Protocol should be resistant
    assert!(profit == Felt::ZERO, "Vulnerable to oracle manipulation");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Use TWAP oracles, multiple oracle sources, sanity checks.</p>
<h3 id="6-flash-loan-attacks"><a class="header" href="#6-flash-loan-attacks">6. Flash Loan Attacks</a></h3>
<p><strong>Description:</strong> Attackers use flash loans to manipulate markets or exploit protocols.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_flash_loan_attack() {
    let env = Environment::builder().build().await?;
    let world = World::new(env);
    
    // Setup protocol and flash loan attacker
    let protocol = setup_vulnerable_protocol(&amp;world).await?;
    world.add_agent(Agent::new("attacker", FlashLoanAttacker::new()));
    
    let initial_tvl = protocol.get_tvl().await?;
    
    world.run_for_blocks(10).await?;
    
    let final_tvl = protocol.get_tvl().await?;
    
    // TVL should not be drained
    assert!(final_tvl &gt;= initial_tvl * 99 / 100, "Vulnerable to flash loan attack");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Circuit breakers, time delays, borrowing limits.</p>
<h3 id="7-denial-of-service"><a class="header" href="#7-denial-of-service">7. Denial of Service</a></h3>
<p><strong>Description:</strong> Attackers prevent legitimate users from using the contract.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_dos_vulnerability() {
    let env = Environment::builder().build().await?;
    let contract = deploy_contract(&amp;env).await?;
    
    // Attacker fills contract storage
    let attacker = env.create_account().await?;
    for i in 0..1000 {
        contract.add_item(&amp;attacker, i).await?;
    }
    
    // Legitimate user should still be able to interact
    let user = env.create_account().await?;
    let result = contract.use_contract(&amp;user).await;
    
    assert!(result.is_ok(), "Vulnerable to DoS");
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Gas limits, rate limiting, bounded iterations.</p>
<h3 id="8-insufficient-validation"><a class="header" href="#8-insufficient-validation">8. Insufficient Validation</a></h3>
<p><strong>Description:</strong> Missing input validation allows invalid states.</p>
<p><strong>Detection with Starkbiter:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_validation_vulnerability() {
    let env = Environment::builder().build().await?;
    let contract = deploy_contract(&amp;env).await?;
    
    // Try invalid inputs
    let invalid_inputs = vec![
        Felt::ZERO,
        Felt::from(u128::MAX),
        Felt::from(-1i128),
    ];
    
    for input in invalid_inputs {
        let result = contract.process(input).await;
        assert!(result.is_err(), "Missing validation for: {:?}", input);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Prevention:</strong> Comprehensive input validation, require statements.</p>
<h2 id="using-the-corpus"><a class="header" href="#using-the-corpus">Using the Corpus</a></h2>
<h3 id="testing-your-contracts"><a class="header" href="#testing-your-contracts">Testing Your Contracts</a></h3>
<ol>
<li>Review applicable vulnerability categories</li>
<li>Implement detection tests for your contract</li>
<li>Run tests with Starkbiter</li>
<li>Fix identified issues</li>
<li>Re-test</li>
</ol>
<h3 id="contributing-1"><a class="header" href="#contributing-1">Contributing</a></h3>
<p>If you discover a new vulnerability pattern:</p>
<ol>
<li>Document the vulnerability</li>
<li>Create a detection test</li>
<li>Submit a PR to this corpus</li>
<li>Include mitigation strategies</li>
</ol>
<h2 id="resources-1"><a class="header" href="#resources-1">Resources</a></h2>
<ul>
<li><a href="https://docs.starknet.io/documentation/security/">Starknet Security Best Practices</a></li>
<li><a href="https://github.com/crytic/building-secure-contracts">Cairo Smart Contract Security</a></li>
<li><a href="https://github.com/OffcierCia/DeFi-Developer-Road-Map">DeFi Security Papers</a></li>
</ul>
<h2 id="next-steps-24"><a class="header" href="#next-steps-24">Next Steps</a></h2>
<ul>
<li><a href="contributing/../advanced/testing_strategies.html">Testing Strategies</a> - Advanced testing techniques</li>
<li><a href="contributing/../advanced/anomaly_detection.html">Anomaly Detection</a> - Detecting vulnerabilities</li>
<li><a href="contributing/../getting_started/examples.html">Examples</a> - See detection in action</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
